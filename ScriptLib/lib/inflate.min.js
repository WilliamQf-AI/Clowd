function ZStream() { } function Inflate() { this.was = [0] } function InfBlocks(t, i, e) { this.hufts = new Int32Array(3 * MANY), this.window = new Uint8Array(e), this.end = e, this.checkfn = i, this.mode = IB_TYPE, this.reset(t, null), this.left = 0, this.table = 0, this.index = 0, this.blens = null, this.bb = new Int32Array(1), this.tb = new Int32Array(1), this.codes = new InfCodes, this.last = 0, this.bitk = 0, this.bitb = 0, this.read = 0, this.write = 0, this.check = 0, this.inftree = new InfTree } function InfCodes() { } function InfTree() { } function inflate_trees_fixed(t, i, e, n, s) { return t[0] = fixed_bl, i[0] = fixed_bd, e[0] = fixed_tl, n[0] = fixed_td, Z_OK } function arrayCopy(t, i, e, n, s) { if (0 != s) { if (!t) throw "Undef src"; if (!e) throw "Undef dest"; 0 == i && s == t.length ? arrayCopy_fast(t, e, n) : hasSubarray ? arrayCopy_fast(t.subarray(i, i + s), e, n) : 1 == t.BYTES_PER_ELEMENT && s > 100 ? arrayCopy_fast(new Uint8Array(t.buffer, t.byteOffset + i, s), e, n) : arrayCopy_slow(t, i, e, n, s) } } function arrayCopy_slow(t, i, e, n, s) { for (var _ = 0; s > _; ++_) e[n + _] = t[i + _] } function arrayCopy_fast(t, i, e) { i.set(t, e) } function adler32(t, i, e, n) { if (null == i) return 1; for (var s, _ = 65535 & t, a = t >> 16 & 65535; n > 0;) { for (s = ADLER_NMAX > n ? n : ADLER_NMAX, n -= s; s >= 16;) _ += 255 & i[e++], a += _, _ += 255 & i[e++], a += _, _ += 255 & i[e++], a += _, _ += 255 & i[e++], a += _, _ += 255 & i[e++], a += _, _ += 255 & i[e++], a += _, _ += 255 & i[e++], a += _, _ += 255 & i[e++], a += _, _ += 255 & i[e++], a += _, _ += 255 & i[e++], a += _, _ += 255 & i[e++], a += _, _ += 255 & i[e++], a += _, _ += 255 & i[e++], a += _, _ += 255 & i[e++], a += _, _ += 255 & i[e++], a += _, _ += 255 & i[e++], a += _, s -= 16; if (0 != s) do _ += 255 & i[e++], a += _; while (0 != --s); _ %= ADLER_BASE, a %= ADLER_BASE } return a << 16 | _ } function jszlib_inflate_buffer(t, i, e, n) { t = i ? e ? new Uint8Array(t, i, e) : new Uint8Array(t, i, t.byteLength - i) : new Uint8Array(t); var s = new ZStream; s.inflateInit(DEF_WBITS, !0), s.next_in = t, s.next_in_index = 0, s.avail_in = t.length; for (var _ = [], a = 0; ;) { var r = new Uint8Array(32e3); s.next_out = r, s.next_out_index = 0, s.avail_out = r.length; var h = s.inflate(Z_NO_FLUSH); if (h != Z_OK && h != Z_STREAM_END && h != Z_BUF_ERROR) throw s.msg; if (0 != s.avail_out) { var l = new Uint8Array(r.length - s.avail_out); arrayCopy(r, 0, l, 0, r.length - s.avail_out), r = l } if (_.push(r), a += r.length, h == Z_STREAM_END || h == Z_BUF_ERROR) break } if (n && (n[0] = (i || 0) + s.next_in_index), 1 == _.length) return _[0].buffer; for (var d = new Uint8Array(a), o = 0, f = 0; f < _.length; ++f) { var x = _[f]; arrayCopy(x, 0, d, o, x.length), o += x.length } return d.buffer } var MAX_WBITS = 15, DEF_WBITS = MAX_WBITS, MAX_MEM_LEVEL = 9, MANY = 1440, BMAX = 15, PRESET_DICT = 32, Z_NO_FLUSH = 0, Z_PARTIAL_FLUSH = 1, Z_SYNC_FLUSH = 2, Z_FULL_FLUSH = 3, Z_FINISH = 4, Z_DEFLATED = 8, Z_OK = 0, Z_STREAM_END = 1, Z_NEED_DICT = 2, Z_ERRNO = -1, Z_STREAM_ERROR = -2, Z_DATA_ERROR = -3, Z_MEM_ERROR = -4, Z_BUF_ERROR = -5, Z_VERSION_ERROR = -6, METHOD = 0, FLAG = 1, DICT4 = 2, DICT3 = 3, DICT2 = 4, DICT1 = 5, DICT0 = 6, BLOCKS = 7, CHECK4 = 8, CHECK3 = 9, CHECK2 = 10, CHECK1 = 11, DONE = 12, BAD = 13, inflate_mask = [0, 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023, 2047, 4095, 8191, 16383, 32767, 65535], IB_TYPE = 0, IB_LENS = 1, IB_STORED = 2, IB_TABLE = 3, IB_BTREE = 4, IB_DTREE = 5, IB_CODES = 6, IB_DRY = 7, IB_DONE = 8, IB_BAD = 9, fixed_bl = 9, fixed_bd = 5, fixed_tl = [96, 7, 256, 0, 8, 80, 0, 8, 16, 84, 8, 115, 82, 7, 31, 0, 8, 112, 0, 8, 48, 0, 9, 192, 80, 7, 10, 0, 8, 96, 0, 8, 32, 0, 9, 160, 0, 8, 0, 0, 8, 128, 0, 8, 64, 0, 9, 224, 80, 7, 6, 0, 8, 88, 0, 8, 24, 0, 9, 144, 83, 7, 59, 0, 8, 120, 0, 8, 56, 0, 9, 208, 81, 7, 17, 0, 8, 104, 0, 8, 40, 0, 9, 176, 0, 8, 8, 0, 8, 136, 0, 8, 72, 0, 9, 240, 80, 7, 4, 0, 8, 84, 0, 8, 20, 85, 8, 227, 83, 7, 43, 0, 8, 116, 0, 8, 52, 0, 9, 200, 81, 7, 13, 0, 8, 100, 0, 8, 36, 0, 9, 168, 0, 8, 4, 0, 8, 132, 0, 8, 68, 0, 9, 232, 80, 7, 8, 0, 8, 92, 0, 8, 28, 0, 9, 152, 84, 7, 83, 0, 8, 124, 0, 8, 60, 0, 9, 216, 82, 7, 23, 0, 8, 108, 0, 8, 44, 0, 9, 184, 0, 8, 12, 0, 8, 140, 0, 8, 76, 0, 9, 248, 80, 7, 3, 0, 8, 82, 0, 8, 18, 85, 8, 163, 83, 7, 35, 0, 8, 114, 0, 8, 50, 0, 9, 196, 81, 7, 11, 0, 8, 98, 0, 8, 34, 0, 9, 164, 0, 8, 2, 0, 8, 130, 0, 8, 66, 0, 9, 228, 80, 7, 7, 0, 8, 90, 0, 8, 26, 0, 9, 148, 84, 7, 67, 0, 8, 122, 0, 8, 58, 0, 9, 212, 82, 7, 19, 0, 8, 106, 0, 8, 42, 0, 9, 180, 0, 8, 10, 0, 8, 138, 0, 8, 74, 0, 9, 244, 80, 7, 5, 0, 8, 86, 0, 8, 22, 192, 8, 0, 83, 7, 51, 0, 8, 118, 0, 8, 54, 0, 9, 204, 81, 7, 15, 0, 8, 102, 0, 8, 38, 0, 9, 172, 0, 8, 6, 0, 8, 134, 0, 8, 70, 0, 9, 236, 80, 7, 9, 0, 8, 94, 0, 8, 30, 0, 9, 156, 84, 7, 99, 0, 8, 126, 0, 8, 62, 0, 9, 220, 82, 7, 27, 0, 8, 110, 0, 8, 46, 0, 9, 188, 0, 8, 14, 0, 8, 142, 0, 8, 78, 0, 9, 252, 96, 7, 256, 0, 8, 81, 0, 8, 17, 85, 8, 131, 82, 7, 31, 0, 8, 113, 0, 8, 49, 0, 9, 194, 80, 7, 10, 0, 8, 97, 0, 8, 33, 0, 9, 162, 0, 8, 1, 0, 8, 129, 0, 8, 65, 0, 9, 226, 80, 7, 6, 0, 8, 89, 0, 8, 25, 0, 9, 146, 83, 7, 59, 0, 8, 121, 0, 8, 57, 0, 9, 210, 81, 7, 17, 0, 8, 105, 0, 8, 41, 0, 9, 178, 0, 8, 9, 0, 8, 137, 0, 8, 73, 0, 9, 242, 80, 7, 4, 0, 8, 85, 0, 8, 21, 80, 8, 258, 83, 7, 43, 0, 8, 117, 0, 8, 53, 0, 9, 202, 81, 7, 13, 0, 8, 101, 0, 8, 37, 0, 9, 170, 0, 8, 5, 0, 8, 133, 0, 8, 69, 0, 9, 234, 80, 7, 8, 0, 8, 93, 0, 8, 29, 0, 9, 154, 84, 7, 83, 0, 8, 125, 0, 8, 61, 0, 9, 218, 82, 7, 23, 0, 8, 109, 0, 8, 45, 0, 9, 186, 0, 8, 13, 0, 8, 141, 0, 8, 77, 0, 9, 250, 80, 7, 3, 0, 8, 83, 0, 8, 19, 85, 8, 195, 83, 7, 35, 0, 8, 115, 0, 8, 51, 0, 9, 198, 81, 7, 11, 0, 8, 99, 0, 8, 35, 0, 9, 166, 0, 8, 3, 0, 8, 131, 0, 8, 67, 0, 9, 230, 80, 7, 7, 0, 8, 91, 0, 8, 27, 0, 9, 150, 84, 7, 67, 0, 8, 123, 0, 8, 59, 0, 9, 214, 82, 7, 19, 0, 8, 107, 0, 8, 43, 0, 9, 182, 0, 8, 11, 0, 8, 139, 0, 8, 75, 0, 9, 246, 80, 7, 5, 0, 8, 87, 0, 8, 23, 192, 8, 0, 83, 7, 51, 0, 8, 119, 0, 8, 55, 0, 9, 206, 81, 7, 15, 0, 8, 103, 0, 8, 39, 0, 9, 174, 0, 8, 7, 0, 8, 135, 0, 8, 71, 0, 9, 238, 80, 7, 9, 0, 8, 95, 0, 8, 31, 0, 9, 158, 84, 7, 99, 0, 8, 127, 0, 8, 63, 0, 9, 222, 82, 7, 27, 0, 8, 111, 0, 8, 47, 0, 9, 190, 0, 8, 15, 0, 8, 143, 0, 8, 79, 0, 9, 254, 96, 7, 256, 0, 8, 80, 0, 8, 16, 84, 8, 115, 82, 7, 31, 0, 8, 112, 0, 8, 48, 0, 9, 193, 80, 7, 10, 0, 8, 96, 0, 8, 32, 0, 9, 161, 0, 8, 0, 0, 8, 128, 0, 8, 64, 0, 9, 225, 80, 7, 6, 0, 8, 88, 0, 8, 24, 0, 9, 145, 83, 7, 59, 0, 8, 120, 0, 8, 56, 0, 9, 209, 81, 7, 17, 0, 8, 104, 0, 8, 40, 0, 9, 177, 0, 8, 8, 0, 8, 136, 0, 8, 72, 0, 9, 241, 80, 7, 4, 0, 8, 84, 0, 8, 20, 85, 8, 227, 83, 7, 43, 0, 8, 116, 0, 8, 52, 0, 9, 201, 81, 7, 13, 0, 8, 100, 0, 8, 36, 0, 9, 169, 0, 8, 4, 0, 8, 132, 0, 8, 68, 0, 9, 233, 80, 7, 8, 0, 8, 92, 0, 8, 28, 0, 9, 153, 84, 7, 83, 0, 8, 124, 0, 8, 60, 0, 9, 217, 82, 7, 23, 0, 8, 108, 0, 8, 44, 0, 9, 185, 0, 8, 12, 0, 8, 140, 0, 8, 76, 0, 9, 249, 80, 7, 3, 0, 8, 82, 0, 8, 18, 85, 8, 163, 83, 7, 35, 0, 8, 114, 0, 8, 50, 0, 9, 197, 81, 7, 11, 0, 8, 98, 0, 8, 34, 0, 9, 165, 0, 8, 2, 0, 8, 130, 0, 8, 66, 0, 9, 229, 80, 7, 7, 0, 8, 90, 0, 8, 26, 0, 9, 149, 84, 7, 67, 0, 8, 122, 0, 8, 58, 0, 9, 213, 82, 7, 19, 0, 8, 106, 0, 8, 42, 0, 9, 181, 0, 8, 10, 0, 8, 138, 0, 8, 74, 0, 9, 245, 80, 7, 5, 0, 8, 86, 0, 8, 22, 192, 8, 0, 83, 7, 51, 0, 8, 118, 0, 8, 54, 0, 9, 205, 81, 7, 15, 0, 8, 102, 0, 8, 38, 0, 9, 173, 0, 8, 6, 0, 8, 134, 0, 8, 70, 0, 9, 237, 80, 7, 9, 0, 8, 94, 0, 8, 30, 0, 9, 157, 84, 7, 99, 0, 8, 126, 0, 8, 62, 0, 9, 221, 82, 7, 27, 0, 8, 110, 0, 8, 46, 0, 9, 189, 0, 8, 14, 0, 8, 142, 0, 8, 78, 0, 9, 253, 96, 7, 256, 0, 8, 81, 0, 8, 17, 85, 8, 131, 82, 7, 31, 0, 8, 113, 0, 8, 49, 0, 9, 195, 80, 7, 10, 0, 8, 97, 0, 8, 33, 0, 9, 163, 0, 8, 1, 0, 8, 129, 0, 8, 65, 0, 9, 227, 80, 7, 6, 0, 8, 89, 0, 8, 25, 0, 9, 147, 83, 7, 59, 0, 8, 121, 0, 8, 57, 0, 9, 211, 81, 7, 17, 0, 8, 105, 0, 8, 41, 0, 9, 179, 0, 8, 9, 0, 8, 137, 0, 8, 73, 0, 9, 243, 80, 7, 4, 0, 8, 85, 0, 8, 21, 80, 8, 258, 83, 7, 43, 0, 8, 117, 0, 8, 53, 0, 9, 203, 81, 7, 13, 0, 8, 101, 0, 8, 37, 0, 9, 171, 0, 8, 5, 0, 8, 133, 0, 8, 69, 0, 9, 235, 80, 7, 8, 0, 8, 93, 0, 8, 29, 0, 9, 155, 84, 7, 83, 0, 8, 125, 0, 8, 61, 0, 9, 219, 82, 7, 23, 0, 8, 109, 0, 8, 45, 0, 9, 187, 0, 8, 13, 0, 8, 141, 0, 8, 77, 0, 9, 251, 80, 7, 3, 0, 8, 83, 0, 8, 19, 85, 8, 195, 83, 7, 35, 0, 8, 115, 0, 8, 51, 0, 9, 199, 81, 7, 11, 0, 8, 99, 0, 8, 35, 0, 9, 167, 0, 8, 3, 0, 8, 131, 0, 8, 67, 0, 9, 231, 80, 7, 7, 0, 8, 91, 0, 8, 27, 0, 9, 151, 84, 7, 67, 0, 8, 123, 0, 8, 59, 0, 9, 215, 82, 7, 19, 0, 8, 107, 0, 8, 43, 0, 9, 183, 0, 8, 11, 0, 8, 139, 0, 8, 75, 0, 9, 247, 80, 7, 5, 0, 8, 87, 0, 8, 23, 192, 8, 0, 83, 7, 51, 0, 8, 119, 0, 8, 55, 0, 9, 207, 81, 7, 15, 0, 8, 103, 0, 8, 39, 0, 9, 175, 0, 8, 7, 0, 8, 135, 0, 8, 71, 0, 9, 239, 80, 7, 9, 0, 8, 95, 0, 8, 31, 0, 9, 159, 84, 7, 99, 0, 8, 127, 0, 8, 63, 0, 9, 223, 82, 7, 27, 0, 8, 111, 0, 8, 47, 0, 9, 191, 0, 8, 15, 0, 8, 143, 0, 8, 79, 0, 9, 255], fixed_td = [80, 5, 1, 87, 5, 257, 83, 5, 17, 91, 5, 4097, 81, 5, 5, 89, 5, 1025, 85, 5, 65, 93, 5, 16385, 80, 5, 3, 88, 5, 513, 84, 5, 33, 92, 5, 8193, 82, 5, 9, 90, 5, 2049, 86, 5, 129, 192, 5, 24577, 80, 5, 2, 87, 5, 385, 83, 5, 25, 91, 5, 6145, 81, 5, 7, 89, 5, 1537, 85, 5, 97, 93, 5, 24577, 80, 5, 4, 88, 5, 769, 84, 5, 49, 92, 5, 12289, 82, 5, 13, 90, 5, 3073, 86, 5, 193, 192, 5, 24577], cplens = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], cplext = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 112, 112], cpdist = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577], cpdext = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]; ZStream.prototype.inflateInit = function (t, i) { return t || (t = DEF_WBITS), i && (i = !1), this.istate = new Inflate, this.istate.inflateInit(this, i ? -t : t) }, ZStream.prototype.inflate = function (t) { return null == this.istate ? Z_STREAM_ERROR : this.istate.inflate(this, t) }, ZStream.prototype.inflateEnd = function () { if (null == this.istate) return Z_STREAM_ERROR; var t = istate.inflateEnd(this); return this.istate = null, t }, ZStream.prototype.inflateSync = function () { return istate.inflateSync(this) }, ZStream.prototype.inflateSetDictionary = function (t, i) { return istate.inflateSetDictionary(this, t, i) }, Inflate.prototype.inflateReset = function (t) { return null == t || null == t.istate ? Z_STREAM_ERROR : (t.total_in = t.total_out = 0, t.msg = null, t.istate.mode = 0 != t.istate.nowrap ? BLOCKS : METHOD, t.istate.blocks.reset(t, null), Z_OK) }, Inflate.prototype.inflateEnd = function (t) { return null != this.blocks && this.blocks.free(t), this.blocks = null, Z_OK }, Inflate.prototype.inflateInit = function (t, i) { return t.msg = null, this.blocks = null, nowrap = 0, 0 > i && (i = -i, nowrap = 1), 8 > i || i > 15 ? (this.inflateEnd(t), Z_STREAM_ERROR) : (this.wbits = i, t.istate.blocks = new InfBlocks(t, 0 != t.istate.nowrap ? null : this, 1 << i), this.inflateReset(t), Z_OK) }, Inflate.prototype.inflate = function (t, i) { var e, n; if (null == t || null == t.istate || null == t.next_in) return Z_STREAM_ERROR; for (i = i == Z_FINISH ? Z_BUF_ERROR : Z_OK, e = Z_BUF_ERROR; ;) switch (t.istate.mode) { case METHOD: if (0 == t.avail_in) return e; if (e = i, t.avail_in--, t.total_in++, (15 & (t.istate.method = t.next_in[t.next_in_index++])) != Z_DEFLATED) { t.istate.mode = BAD, t.msg = "unknown compression method", t.istate.marker = 5; break } if ((t.istate.method >> 4) + 8 > t.istate.wbits) { t.istate.mode = BAD, t.msg = "invalid window size", t.istate.marker = 5; break } t.istate.mode = FLAG; case FLAG: if (0 == t.avail_in) return e; if (e = i, t.avail_in--, t.total_in++, n = 255 & t.next_in[t.next_in_index++], ((t.istate.method << 8) + n) % 31 != 0) { t.istate.mode = BAD, t.msg = "incorrect header check", t.istate.marker = 5; break } if (0 == (n & PRESET_DICT)) { t.istate.mode = BLOCKS; break } t.istate.mode = DICT4; case DICT4: if (0 == t.avail_in) return e; e = i, t.avail_in--, t.total_in++, t.istate.need = (255 & t.next_in[t.next_in_index++]) << 24 & 4278190080, t.istate.mode = DICT3; case DICT3: if (0 == t.avail_in) return e; e = i, t.avail_in--, t.total_in++, t.istate.need += (255 & t.next_in[t.next_in_index++]) << 16 & 16711680, t.istate.mode = DICT2; case DICT2: if (0 == t.avail_in) return e; e = i, t.avail_in--, t.total_in++, t.istate.need += (255 & t.next_in[t.next_in_index++]) << 8 & 65280, t.istate.mode = DICT1; case DICT1: return 0 == t.avail_in ? e : (e = i, t.avail_in--, t.total_in++, t.istate.need += 255 & t.next_in[t.next_in_index++], t.adler = t.istate.need, t.istate.mode = DICT0, Z_NEED_DICT); case DICT0: return t.istate.mode = BAD, t.msg = "need dictionary", t.istate.marker = 0, Z_STREAM_ERROR; case BLOCKS: if (e = t.istate.blocks.proc(t, e), e == Z_DATA_ERROR) { t.istate.mode = BAD, t.istate.marker = 0; break } if (e == Z_OK && (e = i), e != Z_STREAM_END) return e; if (e = i, t.istate.blocks.reset(t, t.istate.was), 0 != t.istate.nowrap) { t.istate.mode = DONE; break } t.istate.mode = CHECK4; case CHECK4: if (0 == t.avail_in) return e; e = i, t.avail_in--, t.total_in++, t.istate.need = (255 & t.next_in[t.next_in_index++]) << 24 & 4278190080, t.istate.mode = CHECK3; case CHECK3: if (0 == t.avail_in) return e; e = i, t.avail_in--, t.total_in++, t.istate.need += (255 & t.next_in[t.next_in_index++]) << 16 & 16711680, t.istate.mode = CHECK2; case CHECK2: if (0 == t.avail_in) return e; e = i, t.avail_in--, t.total_in++, t.istate.need += (255 & t.next_in[t.next_in_index++]) << 8 & 65280, t.istate.mode = CHECK1; case CHECK1: if (0 == t.avail_in) return e; if (e = i, t.avail_in--, t.total_in++, t.istate.need += 255 & t.next_in[t.next_in_index++], t.istate.was[0] != t.istate.need) { t.istate.mode = BAD, t.msg = "incorrect data check", t.istate.marker = 5; break } t.istate.mode = DONE; case DONE: return Z_STREAM_END; case BAD: return Z_DATA_ERROR; default: return Z_STREAM_ERROR } }, Inflate.prototype.inflateSetDictionary = function (t, i, e) { var n = 0, s = e; return null == t || null == t.istate || t.istate.mode != DICT0 ? Z_STREAM_ERROR : t._adler.adler32(1, i, 0, e) != t.adler ? Z_DATA_ERROR : (t.adler = t._adler.adler32(0, null, 0, 0), s >= 1 << t.istate.wbits && (s = (1 << t.istate.wbits) - 1, n = e - s), t.istate.blocks.set_dictionary(i, n, s), t.istate.mode = BLOCKS, Z_OK) }; var mark = [0, 0, 255, 255]; Inflate.prototype.inflateSync = function (t) { var i, e, n, s, _; if (null == t || null == t.istate) return Z_STREAM_ERROR; if (t.istate.mode != BAD && (t.istate.mode = BAD, t.istate.marker = 0), 0 == (i = t.avail_in)) return Z_BUF_ERROR; for (e = t.next_in_index, n = t.istate.marker; 0 != i && 4 > n;) t.next_in[e] == mark[n] ? n++ : n = 0 != t.next_in[e] ? 0 : 4 - n, e++, i--; return t.total_in += e - t.next_in_index, t.next_in_index = e, t.avail_in = i, t.istate.marker = n, 4 != n ? Z_DATA_ERROR : (s = t.total_in, _ = t.total_out, this.inflateReset(t), t.total_in = s, t.total_out = _, t.istate.mode = BLOCKS, Z_OK) }, Inflate.prototype.inflateSyncPoint = function (t) { return null == t || null == t.istate || null == t.istate.blocks ? Z_STREAM_ERROR : t.istate.blocks.sync_point() }; var INFBLOCKS_BORDER = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]; InfBlocks.prototype.reset = function (t, i) { i && (i[0] = this.check), this.mode == IB_CODES && this.codes.free(t), this.mode = IB_TYPE, this.bitk = 0, this.bitb = 0, this.read = this.write = 0, this.checkfn && (t.adler = this.check = t._adler.adler32(0, null, 0, 0)) }, InfBlocks.prototype.proc = function (t, i) { var e, n, s, _, a, r, h; for (_ = t.next_in_index, a = t.avail_in, n = this.bitb, s = this.bitk, r = this.write, h = r < this.read ? this.read - r - 1 : this.end - r; ;) switch (this.mode) { case IB_TYPE: for (; 3 > s;) { if (0 == a) return this.bitb = n, this.bitk = s, t.avail_in = a, t.total_in += _ - t.next_in_index, t.next_in_index = _, this.write = r, this.inflate_flush(t, i); i = Z_OK, a--, n |= (255 & t.next_in[_++]) << s, s += 8 } switch (e = 7 & n, this.last = 1 & e, e >>> 1) { case 0: n >>>= 3, s -= 3, e = 7 & s, n >>>= e, s -= e, this.mode = IB_LENS; break; case 1: var l = new Int32Array(1), d = new Int32Array(1), o = [], f = []; inflate_trees_fixed(l, d, o, f, t), this.codes.init(l[0], d[0], o[0], 0, f[0], 0, t), n >>>= 3, s -= 3, this.mode = IB_CODES; break; case 2: n >>>= 3, s -= 3, this.mode = IB_TABLE; break; case 3: return n >>>= 3, s -= 3, this.mode = BAD, t.msg = "invalid block type", i = Z_DATA_ERROR, this.bitb = n, this.bitk = s, t.avail_in = a, t.total_in += _ - t.next_in_index, t.next_in_index = _, this.write = r, this.inflate_flush(t, i) } break; case IB_LENS: for (; 32 > s;) { if (0 == a) return this.bitb = n, this.bitk = s, t.avail_in = a, t.total_in += _ - t.next_in_index, t.next_in_index = _, this.write = r, this.inflate_flush(t, i); i = Z_OK, a--, n |= (255 & t.next_in[_++]) << s, s += 8 } if ((~n >>> 16 & 65535) != (65535 & n)) return this.mode = BAD, t.msg = "invalid stored block lengths", i = Z_DATA_ERROR, this.bitb = n, this.bitk = s, t.avail_in = a, t.total_in += _ - t.next_in_index, t.next_in_index = _, this.write = r, this.inflate_flush(t, i); this.left = 65535 & n, n = s = 0, this.mode = 0 != this.left ? IB_STORED : 0 != this.last ? IB_DRY : IB_TYPE; break; case IB_STORED: if (0 == a) return this.bitb = n, this.bitk = s, t.avail_in = a, t.total_in += _ - t.next_in_index, t.next_in_index = _, write = r, this.inflate_flush(t, i); if (0 == h && (r == end && 0 != read && (r = 0, h = r < this.read ? this.read - r - 1 : this.end - r), 0 == h && (this.write = r, i = this.inflate_flush(t, i), r = this.write, h = r < this.read ? this.read - r - 1 : this.end - r, r == this.end && 0 != this.read && (r = 0, h = r < this.read ? this.read - r - 1 : this.end - r), 0 == h))) return this.bitb = n, this.bitk = s, t.avail_in = a, t.total_in += _ - t.next_in_index, t.next_in_index = _, this.write = r, this.inflate_flush(t, i); if (i = Z_OK, e = this.left, e > a && (e = a), e > h && (e = h), arrayCopy(t.next_in, _, this.window, r, e), _ += e, a -= e, r += e, h -= e, 0 != (this.left -= e)) break; this.mode = 0 != this.last ? IB_DRY : IB_TYPE; break; case IB_TABLE: for (; 14 > s;) { if (0 == a) return this.bitb = n, this.bitk = s, t.avail_in = a, t.total_in += _ - t.next_in_index, t.next_in_index = _, this.write = r, this.inflate_flush(t, i); i = Z_OK, a--, n |= (255 & t.next_in[_++]) << s, s += 8 } if (this.table = e = 16383 & n, (31 & e) > 29 || (e >> 5 & 31) > 29) return this.mode = IB_BAD, t.msg = "too many length or distance symbols", i = Z_DATA_ERROR, this.bitb = n, this.bitk = s, t.avail_in = a, t.total_in += _ - t.next_in_index, t.next_in_index = _, this.write = r, this.inflate_flush(t, i); if (e = 258 + (31 & e) + (e >> 5 & 31), null == this.blens || this.blens.length < e) this.blens = new Int32Array(e); else for (var x = 0; e > x; x++) this.blens[x] = 0; n >>>= 14, s -= 14, this.index = 0, mode = IB_BTREE; case IB_BTREE: for (; this.index < 4 + (this.table >>> 10) ;) { for (; 3 > s;) { if (0 == a) return this.bitb = n, this.bitk = s, t.avail_in = a, t.total_in += _ - t.next_in_index, t.next_in_index = _, this.write = r, this.inflate_flush(t, i); i = Z_OK, a--, n |= (255 & t.next_in[_++]) << s, s += 8 } this.blens[INFBLOCKS_BORDER[this.index++]] = 7 & n, n >>>= 3, s -= 3 } for (; this.index < 19;) this.blens[INFBLOCKS_BORDER[this.index++]] = 0; if (this.bb[0] = 7, e = this.inftree.inflate_trees_bits(this.blens, this.bb, this.tb, this.hufts, t), e != Z_OK) return i = e, i == Z_DATA_ERROR && (this.blens = null, this.mode = IB_BAD), this.bitb = n, this.bitk = s, t.avail_in = a, t.total_in += _ - t.next_in_index, t.next_in_index = _, write = r, this.inflate_flush(t, i); this.index = 0, this.mode = IB_DTREE; case IB_DTREE: for (; ;) { if (e = this.table, !(this.index < 258 + (31 & e) + (e >> 5 & 31))) break; var x, u, b; for (e = this.bb[0]; e > s;) { if (0 == a) return this.bitb = n, this.bitk = s, t.avail_in = a, t.total_in += _ - t.next_in_index, t.next_in_index = _, this.write = r, this.inflate_flush(t, i); i = Z_OK, a--, n |= (255 & t.next_in[_++]) << s, s += 8 } if (e = this.hufts[3 * (this.tb[0] + (n & inflate_mask[e])) + 1], b = this.hufts[3 * (this.tb[0] + (n & inflate_mask[e])) + 2], 16 > b) n >>>= e, s -= e, this.blens[this.index++] = b; else { for (x = 18 == b ? 7 : b - 14, u = 18 == b ? 11 : 3; e + x > s;) { if (0 == a) return this.bitb = n, this.bitk = s, t.avail_in = a, t.total_in += _ - t.next_in_index, t.next_in_index = _, this.write = r, this.inflate_flush(t, i); i = Z_OK, a--, n |= (255 & t.next_in[_++]) << s, s += 8 } if (n >>>= e, s -= e, u += n & inflate_mask[x], n >>>= x, s -= x, x = this.index, e = this.table, x + u > 258 + (31 & e) + (e >> 5 & 31) || 16 == b && 1 > x) return this.blens = null, this.mode = IB_BAD, t.msg = "invalid bit length repeat", i = Z_DATA_ERROR, this.bitb = n, this.bitk = s, t.avail_in = a, t.total_in += _ - t.next_in_index, t.next_in_index = _, this.write = r, this.inflate_flush(t, i); b = 16 == b ? this.blens[x - 1] : 0; do this.blens[x++] = b; while (0 != --u); this.index = x } } this.tb[0] = -1; var l = new Int32Array(1), d = new Int32Array(1), o = new Int32Array(1), f = new Int32Array(1); if (l[0] = 9, d[0] = 6, e = this.table, e = this.inftree.inflate_trees_dynamic(257 + (31 & e), 1 + (e >> 5 & 31), this.blens, l, d, o, f, this.hufts, t), e != Z_OK) return e == Z_DATA_ERROR && (this.blens = null, this.mode = BAD), i = e, this.bitb = n, this.bitk = s, t.avail_in = a, t.total_in += _ - t.next_in_index, t.next_in_index = _, this.write = r, this.inflate_flush(t, i); this.codes.init(l[0], d[0], this.hufts, o[0], this.hufts, f[0], t), this.mode = IB_CODES; case IB_CODES: if (this.bitb = n, this.bitk = s, t.avail_in = a, t.total_in += _ - t.next_in_index, t.next_in_index = _, this.write = r, (i = this.codes.proc(this, t, i)) != Z_STREAM_END) return this.inflate_flush(t, i); if (i = Z_OK, this.codes.free(t), _ = t.next_in_index, a = t.avail_in, n = this.bitb, s = this.bitk, r = this.write, h = r < this.read ? this.read - r - 1 : this.end - r, 0 == this.last) { this.mode = IB_TYPE; break } this.mode = IB_DRY; case IB_DRY: if (this.write = r, i = this.inflate_flush(t, i), r = this.write, h = r < this.read ? this.read - r - 1 : this.end - r, this.read != this.write) return this.bitb = n, this.bitk = s, t.avail_in = a, t.total_in += _ - t.next_in_index, t.next_in_index = _, this.write = r, this.inflate_flush(t, i); mode = DONE; case IB_DONE: return i = Z_STREAM_END, this.bitb = n, this.bitk = s, t.avail_in = a, t.total_in += _ - t.next_in_index, t.next_in_index = _, this.write = r, this.inflate_flush(t, i); case IB_BAD: return i = Z_DATA_ERROR, this.bitb = n, this.bitk = s, t.avail_in = a, t.total_in += _ - t.next_in_index, t.next_in_index = _, this.write = r, this.inflate_flush(t, i); default: return i = Z_STREAM_ERROR, this.bitb = n, this.bitk = s, t.avail_in = a, t.total_in += _ - t.next_in_index, t.next_in_index = _, this.write = r, this.inflate_flush(t, i) } }, InfBlocks.prototype.free = function (t) { this.reset(t, null), this.window = null, this.hufts = null }, InfBlocks.prototype.set_dictionary = function (t, i, e) { arrayCopy(t, i, window, 0, e), this.read = this.write = e }, InfBlocks.prototype.sync_point = function () { return this.mode == IB_LENS }, InfBlocks.prototype.inflate_flush = function (t, i) { var e, n, s; return n = t.next_out_index, s = this.read, e = (s <= this.write ? this.write : this.end) - s, e > t.avail_out && (e = t.avail_out), 0 != e && i == Z_BUF_ERROR && (i = Z_OK), t.avail_out -= e, t.total_out += e, null != this.checkfn && (t.adler = this.check = t._adler.adler32(this.check, this.window, s, e)), arrayCopy(this.window, s, t.next_out, n, e), n += e, s += e, s == this.end && (s = 0, this.write == this.end && (this.write = 0), e = this.write - s, e > t.avail_out && (e = t.avail_out), 0 != e && i == Z_BUF_ERROR && (i = Z_OK), t.avail_out -= e, t.total_out += e, null != this.checkfn && (t.adler = this.check = t._adler.adler32(this.check, this.window, s, e)), arrayCopy(this.window, s, t.next_out, n, e), n += e, s += e), t.next_out_index = n, this.read = s, i }; var IC_START = 0, IC_LEN = 1, IC_LENEXT = 2, IC_DIST = 3, IC_DISTEXT = 4, IC_COPY = 5, IC_LIT = 6, IC_WASH = 7, IC_END = 8, IC_BADCODE = 9; InfCodes.prototype.init = function (t, i, e, n, s, _, a) { this.mode = IC_START, this.lbits = t, this.dbits = i, this.ltree = e, this.ltree_index = n, this.dtree = s, this.dtree_index = _, this.tree = null }, InfCodes.prototype.proc = function (t, i, e) { var n, s, _, a, r, h, l, d = 0, o = 0, f = 0; for (f = i.next_in_index, a = i.avail_in, d = t.bitb, o = t.bitk, r = t.write, h = r < t.read ? t.read - r - 1 : t.end - r; ;) switch (this.mode) { case IC_START: if (h >= 258 && a >= 10 && (t.bitb = d, t.bitk = o, i.avail_in = a, i.total_in += f - i.next_in_index, i.next_in_index = f, t.write = r, e = this.inflate_fast(this.lbits, this.dbits, this.ltree, this.ltree_index, this.dtree, this.dtree_index, t, i), f = i.next_in_index, a = i.avail_in, d = t.bitb, o = t.bitk, r = t.write, h = r < t.read ? t.read - r - 1 : t.end - r, e != Z_OK)) { this.mode = e == Z_STREAM_END ? IC_WASH : IC_BADCODE; break } this.need = this.lbits, this.tree = this.ltree, this.tree_index = this.ltree_index, this.mode = IC_LEN; case IC_LEN: for (n = this.need; n > o;) { if (0 == a) return t.bitb = d, t.bitk = o, i.avail_in = a, i.total_in += f - i.next_in_index, i.next_in_index = f, t.write = r, t.inflate_flush(i, e); e = Z_OK, a--, d |= (255 & i.next_in[f++]) << o, o += 8 } if (s = 3 * (this.tree_index + (d & inflate_mask[n])), d >>>= this.tree[s + 1], o -= this.tree[s + 1], _ = this.tree[s], 0 == _) { this.lit = this.tree[s + 2], this.mode = IC_LIT; break } if (0 != (16 & _)) { this.get = 15 & _, this.len = this.tree[s + 2], this.mode = IC_LENEXT; break } if (0 == (64 & _)) { this.need = _, this.tree_index = s / 3 + this.tree[s + 2]; break } if (0 != (32 & _)) { this.mode = IC_WASH; break } return this.mode = IC_BADCODE, i.msg = "invalid literal/length code", e = Z_DATA_ERROR, t.bitb = d, t.bitk = o, i.avail_in = a, i.total_in += f - i.next_in_index, i.next_in_index = f, t.write = r, t.inflate_flush(i, e); case IC_LENEXT: for (n = this.get; n > o;) { if (0 == a) return t.bitb = d, t.bitk = o, i.avail_in = a, i.total_in += f - i.next_in_index, i.next_in_index = f, t.write = r, t.inflate_flush(i, e); e = Z_OK, a--, d |= (255 & i.next_in[f++]) << o, o += 8 } this.len += d & inflate_mask[n], d >>= n, o -= n, this.need = this.dbits, this.tree = this.dtree, this.tree_index = this.dtree_index, this.mode = IC_DIST; case IC_DIST: for (n = this.need; n > o;) { if (0 == a) return t.bitb = d, t.bitk = o, i.avail_in = a, i.total_in += f - i.next_in_index, i.next_in_index = f, t.write = r, t.inflate_flush(i, e); e = Z_OK, a--, d |= (255 & i.next_in[f++]) << o, o += 8 } if (s = 3 * (this.tree_index + (d & inflate_mask[n])), d >>= this.tree[s + 1], o -= this.tree[s + 1], _ = this.tree[s], 0 != (16 & _)) { this.get = 15 & _, this.dist = this.tree[s + 2], this.mode = IC_DISTEXT; break } if (0 == (64 & _)) { this.need = _, this.tree_index = s / 3 + this.tree[s + 2]; break } return this.mode = IC_BADCODE, i.msg = "invalid distance code", e = Z_DATA_ERROR, t.bitb = d, t.bitk = o, i.avail_in = a, i.total_in += f - i.next_in_index, i.next_in_index = f, t.write = r, t.inflate_flush(i, e); case IC_DISTEXT: for (n = this.get; n > o;) { if (0 == a) return t.bitb = d, t.bitk = o, i.avail_in = a, i.total_in += f - i.next_in_index, i.next_in_index = f, t.write = r, t.inflate_flush(i, e); e = Z_OK, a--, d |= (255 & i.next_in[f++]) << o, o += 8 } this.dist += d & inflate_mask[n], d >>= n, o -= n, this.mode = IC_COPY; case IC_COPY: for (l = r - this.dist; 0 > l;) l += t.end; for (; 0 != this.len;) { if (0 == h && (r == t.end && 0 != t.read && (r = 0, h = r < t.read ? t.read - r - 1 : t.end - r), 0 == h && (t.write = r, e = t.inflate_flush(i, e), r = t.write, h = r < t.read ? t.read - r - 1 : t.end - r, r == t.end && 0 != t.read && (r = 0, h = r < t.read ? t.read - r - 1 : t.end - r), 0 == h))) return t.bitb = d, t.bitk = o, i.avail_in = a, i.total_in += f - i.next_in_index, i.next_in_index = f, t.write = r, t.inflate_flush(i, e); t.window[r++] = t.window[l++], h--, l == t.end && (l = 0), this.len-- } this.mode = IC_START; break; case IC_LIT: if (0 == h && (r == t.end && 0 != t.read && (r = 0, h = r < t.read ? t.read - r - 1 : t.end - r), 0 == h && (t.write = r, e = t.inflate_flush(i, e), r = t.write, h = r < t.read ? t.read - r - 1 : t.end - r, r == t.end && 0 != t.read && (r = 0, h = r < t.read ? t.read - r - 1 : t.end - r), 0 == h))) return t.bitb = d, t.bitk = o, i.avail_in = a, i.total_in += f - i.next_in_index, i.next_in_index = f, t.write = r, t.inflate_flush(i, e); e = Z_OK, t.window[r++] = this.lit, h--, this.mode = IC_START; break; case IC_WASH: if (o > 7 && (o -= 8, a++, f--), t.write = r, e = t.inflate_flush(i, e), r = t.write, h = r < t.read ? t.read - r - 1 : t.end - r, t.read != t.write) return t.bitb = d, t.bitk = o, i.avail_in = a, i.total_in += f - i.next_in_index, i.next_in_index = f, t.write = r, t.inflate_flush(i, e); this.mode = IC_END; case IC_END: return e = Z_STREAM_END, t.bitb = d, t.bitk = o, i.avail_in = a, i.total_in += f - i.next_in_index, i.next_in_index = f, t.write = r, t.inflate_flush(i, e); case IC_BADCODE: return e = Z_DATA_ERROR, t.bitb = d, t.bitk = o, i.avail_in = a, i.total_in += f - i.next_in_index, i.next_in_index = f, t.write = r, t.inflate_flush(i, e); default: return e = Z_STREAM_ERROR, t.bitb = d, t.bitk = o, i.avail_in = a, i.total_in += f - i.next_in_index, i.next_in_index = f, t.write = r, t.inflate_flush(i, e) } }, InfCodes.prototype.free = function (t) { }, InfCodes.prototype.inflate_fast = function (t, i, e, n, s, _, a, r) { var h, l, d, o, f, x, u, b, R, E, c, w, A, I, D, k; u = r.next_in_index, b = r.avail_in, f = a.bitb, x = a.bitk, R = a.write, E = R < a.read ? a.read - R - 1 : a.end - R, c = inflate_mask[t], w = inflate_mask[i]; do { for (; 20 > x;) b--, f |= (255 & r.next_in[u++]) << x, x += 8; if (h = f & c, l = e, d = n, k = 3 * (d + h), 0 != (o = l[k])) for (; ;) { if (f >>= l[k + 1], x -= l[k + 1], 0 != (16 & o)) { for (o &= 15, A = l[k + 2] + (f & inflate_mask[o]), f >>= o, x -= o; 15 > x;) b--, f |= (255 & r.next_in[u++]) << x, x += 8; for (h = f & w, l = s, d = _, k = 3 * (d + h), o = l[k]; ;) { if (f >>= l[k + 1], x -= l[k + 1], 0 != (16 & o)) { for (o &= 15; o > x;) b--, f |= (255 & r.next_in[u++]) << x, x += 8; if (I = l[k + 2] + (f & inflate_mask[o]), f >>= o, x -= o, E -= A, R >= I) D = R - I, R - D > 0 && 2 > R - D ? (a.window[R++] = a.window[D++], a.window[R++] = a.window[D++], A -= 2) : (a.window[R++] = a.window[D++], a.window[R++] = a.window[D++], A -= 2); else { D = R - I; do D += a.end; while (0 > D); if (o = a.end - D, A > o) { if (A -= o, R - D > 0 && o > R - D) { do a.window[R++] = a.window[D++]; while (0 != --o) } else arrayCopy(a.window, D, a.window, R, o), R += o, D += o, o = 0; D = 0 } } do a.window[R++] = a.window[D++]; while (0 != --A); break } if (0 != (64 & o)) return r.msg = "invalid distance code", A = r.avail_in - b, A = A > x >> 3 ? x >> 3 : A, b += A, u -= A, x -= A << 3, a.bitb = f, a.bitk = x, r.avail_in = b, r.total_in += u - r.next_in_index, r.next_in_index = u, a.write = R, Z_DATA_ERROR; h += l[k + 2], h += f & inflate_mask[o], k = 3 * (d + h), o = l[k] } break } if (0 != (64 & o)) return 0 != (32 & o) ? (A = r.avail_in - b, A = A > x >> 3 ? x >> 3 : A, b += A, u -= A, x -= A << 3, a.bitb = f, a.bitk = x, r.avail_in = b, r.total_in += u - r.next_in_index, r.next_in_index = u, a.write = R, Z_STREAM_END) : (r.msg = "invalid literal/length code", A = r.avail_in - b, A = A > x >> 3 ? x >> 3 : A, b += A, u -= A, x -= A << 3, a.bitb = f, a.bitk = x, r.avail_in = b, r.total_in += u - r.next_in_index, r.next_in_index = u, a.write = R, Z_DATA_ERROR); if (h += l[k + 2], h += f & inflate_mask[o], k = 3 * (d + h), 0 == (o = l[k])) { f >>= l[k + 1], x -= l[k + 1], a.window[R++] = l[k + 2], E--; break } } else f >>= l[k + 1], x -= l[k + 1], a.window[R++] = l[k + 2], E-- } while (E >= 258 && b >= 10); return A = r.avail_in - b, A = A > x >> 3 ? x >> 3 : A, b += A, u -= A, x -= A << 3, a.bitb = f, a.bitk = x, r.avail_in = b, r.total_in += u - r.next_in_index, r.next_in_index = u, a.write = R, Z_OK }, InfTree.prototype.huft_build = function (t, i, e, n, s, _, a, r, h, l, d) { var o, f, x, u, b, R, E, c, w, A, I, D, k, m, T; A = 0, b = e; do this.c[t[i + A]]++, A++, b--; while (0 != b); if (this.c[0] == e) return a[0] = -1, r[0] = 0, Z_OK; for (c = r[0], R = 1; BMAX >= R && 0 == this.c[R]; R++); for (E = R, R > c && (c = R), b = BMAX; 0 != b && 0 == this.c[b]; b--); for (x = b, c > b && (c = b), r[0] = c, m = 1 << R; b > R; R++, m <<= 1) if ((m -= this.c[R]) < 0) return Z_DATA_ERROR; if ((m -= this.c[b]) < 0) return Z_DATA_ERROR; for (this.c[b] += m, this.x[1] = R = 0, A = 1, k = 2; 0 != --b;) this.x[k] = R += this.c[A], k++, A++; b = 0, A = 0; do 0 != (R = t[i + A]) && (this.v[this.x[R]++] = b), A++; while (++b < e); for (e = this.x[x], this.x[0] = b = 0, A = 0, u = -1, D = -c, this.u[0] = 0, I = 0, T = 0; x >= E; E++) for (o = this.c[E]; 0 != o--;) { for (; E > D + c;) { if (u++, D += c, T = x - D, T = T > c ? c : T, (f = 1 << (R = E - D)) > o + 1 && (f -= o + 1, k = E, T > R)) for (; ++R < T && !((f <<= 1) <= this.c[++k]) ;) f -= this.c[k]; if (T = 1 << R, this.hn[0] + T > MANY) return Z_DATA_ERROR; this.u[u] = I = this.hn[0], this.hn[0] += T, 0 != u ? (this.x[u] = b, this.r[0] = R, this.r[1] = c, R = b >>> D - c, this.r[2] = I - this.u[u - 1] - R, arrayCopy(this.r, 0, h, 3 * (this.u[u - 1] + R), 3)) : a[0] = I } for (this.r[1] = E - D, A >= e ? this.r[0] = 192 : d[A] < n ? (this.r[0] = this.v[A] < 256 ? 0 : 96, this.r[2] = this.v[A++]) : (this.r[0] = _[this.v[A] - n] + 16 + 64, this.r[2] = s[this.v[A++] - n]), f = 1 << E - D, R = b >>> D; T > R; R += f) arrayCopy(this.r, 0, h, 3 * (I + R), 3); for (R = 1 << E - 1; 0 != (b & R) ; R >>>= 1) b ^= R; for (b ^= R, w = (1 << D) - 1; (b & w) != this.x[u];) u--, D -= c, w = (1 << D) - 1 } return 0 != m && 1 != x ? Z_BUF_ERROR : Z_OK }, InfTree.prototype.inflate_trees_bits = function (t, i, e, n, s) { var _; return this.initWorkArea(19), this.hn[0] = 0, _ = this.huft_build(t, 0, 19, 19, null, null, e, i, n, this.hn, this.v), _ == Z_DATA_ERROR ? s.msg = "oversubscribed dynamic bit lengths tree" : (_ == Z_BUF_ERROR || 0 == i[0]) && (s.msg = "incomplete dynamic bit lengths tree", _ = Z_DATA_ERROR), _ }, InfTree.prototype.inflate_trees_dynamic = function (t, i, e, n, s, _, a, r, h) { var l; return this.initWorkArea(288), this.hn[0] = 0, l = this.huft_build(e, 0, t, 257, cplens, cplext, _, n, r, this.hn, this.v), l != Z_OK || 0 == n[0] ? (l == Z_DATA_ERROR ? h.msg = "oversubscribed literal/length tree" : l != Z_MEM_ERROR && (h.msg = "incomplete literal/length tree", l = Z_DATA_ERROR), l) : (this.initWorkArea(288), l = this.huft_build(e, t, i, 0, cpdist, cpdext, a, s, r, this.hn, this.v), l != Z_OK || 0 == s[0] && t > 257 ? (l == Z_DATA_ERROR ? h.msg = "oversubscribed distance tree" : l == Z_BUF_ERROR ? (h.msg = "incomplete distance tree", l = Z_DATA_ERROR) : l != Z_MEM_ERROR && (h.msg = "empty distance tree with lengths", l = Z_DATA_ERROR), l) : Z_OK) }, InfTree.prototype.initWorkArea = function (t) { null == this.hn && (this.hn = new Int32Array(1), this.v = new Int32Array(t), this.c = new Int32Array(BMAX + 1), this.r = new Int32Array(3), this.u = new Int32Array(BMAX), this.x = new Int32Array(BMAX + 1)), this.v.length < t && (this.v = new Int32Array(t)); for (var i = 0; t > i; i++) this.v[i] = 0; for (var i = 0; BMAX + 1 > i; i++) this.c[i] = 0; for (var i = 0; 3 > i; i++) this.r[i] = 0; arrayCopy(this.c, 0, this.u, 0, BMAX), arrayCopy(this.c, 0, this.x, 0, BMAX + 1) }; var testArray = new Uint8Array(1), hasSubarray = "function" == typeof testArray.subarray, hasSlice = !1, ADLER_BASE = 65521, ADLER_NMAX = 5552; "undefined" != typeof module && (module.exports = { inflateBuffer: jszlib_inflate_buffer, arrayCopy: arrayCopy });
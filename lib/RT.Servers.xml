<?xml version="1.0"?>
<doc>
    <assembly>
        <name>RT.Servers</name>
    </assembly>
    <members>
        <member name="T:RT.Servers.AjaxHandler`1">
            <summary>
                Provides a means to call methods decorated with an <see cref="T:RT.Servers.AjaxMethodAttribute"/> via AJAX, using JSON as the data
                interchange format.</summary>
            <typeparam name="TApi">
                Type of the object containing the Ajax methods to use.</typeparam>
        </member>
        <member name="M:RT.Servers.AjaxHandler`1.#ctor(RT.Servers.AjaxHandlerOptions)">
            <summary>
                Constructs a new instance of <see cref="T:RT.Servers.AjaxHandler`1"/>.</summary>
            <param name="options">
                Specifies <see cref="T:RT.Servers.AjaxHandler`1"/>’s exception behaviour.</param>
        </member>
        <member name="M:RT.Servers.AjaxHandler`1.Handle(RT.Servers.HttpRequest,`0)">
            <summary>
                Provides the handler for AJAX calls. Pass this to a <see cref="T:RT.Servers.UrlMapping"/>.</summary>
            <param name="req">
                The incoming HTTP POST request to be handled, containing the API function name and parameters.</param>
            <param name="api">
                The API object on which the API function is to be invoked.</param>
        </member>
        <member name="T:RT.Servers.AjaxHandlerOptions">
            <summary>Specifies the exception behaviour for <see cref="T:RT.Servers.AjaxHandler`1"/>.</summary>
        </member>
        <member name="F:RT.Servers.AjaxHandlerOptions.ReturnExceptionsWithoutMessages">
            <summary>
                Exceptions thrown by an AJAX method (or the wrapper) are returned to the client as simply <c>{ "status": "error"
                }</c>.</summary>
        </member>
        <member name="F:RT.Servers.AjaxHandlerOptions.ReturnExceptionsWithMessages">
            <summary>
                Exceptions thrown by an AJAX method (or the wrapper) are returned to the client including their exception messages
                as <c>{ "status": "error", "message": "{0} ({1})" }</c>, where <c>{0}</c> is the exception message and <c>{1}</c>
                the exception type.</summary>
        </member>
        <member name="F:RT.Servers.AjaxHandlerOptions.PropagateExceptions">
            <summary>
                <see cref="T:RT.Servers.AjaxHandler`1"/> does not catch exceptions thrown by the API functions. If you do not catch the
                exceptions either, they will bring down the server.</summary>
        </member>
        <member name="T:RT.Servers.AjaxException">
            <summary>Indicates that an error occurred during processing of an AJAX request.</summary>
        </member>
        <member name="M:RT.Servers.AjaxException.#ctor">
            <summary>Constructor.</summary>
        </member>
        <member name="M:RT.Servers.AjaxException.#ctor(System.String)">
            <summary>
                Constructor.</summary>
            <param name="message">
                Exception message.</param>
        </member>
        <member name="M:RT.Servers.AjaxException.#ctor(System.String,System.Exception)">
            <summary>
                Constructor.</summary>
            <param name="message">
                Exception message.</param>
            <param name="inner">
                Inner exception.</param>
        </member>
        <member name="T:RT.Servers.AjaxMethodNotFoundException">
            <summary>Indicates that an AJAX method was requested that does not exist.</summary>
        </member>
        <member name="M:RT.Servers.AjaxMethodNotFoundException.#ctor(System.String)">
            <summary>
                Constructor.</summary>
            <param name="ajaxMethodName">
                Name of the requested method that does not exist.</param>
        </member>
        <member name="M:RT.Servers.AjaxMethodNotFoundException.#ctor(System.String,System.String)">
            <summary>
                Constructor.</summary>
            <param name="ajaxMethodName">
                Name of the requested method that does not exist.</param>
            <param name="message">
                Exception message.</param>
        </member>
        <member name="M:RT.Servers.AjaxMethodNotFoundException.#ctor(System.String,System.String,System.Exception)">
            <summary>
                Constructor.</summary>
            <param name="ajaxMethodName">
                Name of the requested method that does not exist.</param>
            <param name="message">
                Exception message.</param>
            <param name="inner">
                Inner exception.</param>
        </member>
        <member name="P:RT.Servers.AjaxMethodNotFoundException.AjaxMethodName">
            <summary>Gets the name of the requested method that does not exist.</summary>
        </member>
        <member name="T:RT.Servers.AjaxInvalidParameterException">
            <summary>Indicates that, during processing of an AJAX request, the value for a method parameter could not be deseralized.</summary>
        </member>
        <member name="M:RT.Servers.AjaxInvalidParameterException.#ctor(System.String)">
            <summary>
                Constructor.</summary>
            <param name="parameterName">
                Name of the parameter that could not be deserialized.</param>
        </member>
        <member name="M:RT.Servers.AjaxInvalidParameterException.#ctor(System.String,System.String)">
            <summary>
                Constructor.</summary>
            <param name="parameterName">
                Name of the parameter that could not be deserialized.</param>
            <param name="message">
                Exception message.</param>
        </member>
        <member name="M:RT.Servers.AjaxInvalidParameterException.#ctor(System.String,System.Exception)">
            <summary>
                Constructor.</summary>
            <param name="parameterName">
                Name of the parameter that could not be deserialized.</param>
            <param name="inner">
                Inner exception.</param>
        </member>
        <member name="M:RT.Servers.AjaxInvalidParameterException.#ctor(System.String,System.String,System.Exception)">
            <summary>
                Constructor.</summary>
            <param name="parameterName">
                Name of the parameter that could not be deserialized.</param>
            <param name="message">
                Exception message.</param>
            <param name="inner">
                Inner exception.</param>
        </member>
        <member name="P:RT.Servers.AjaxInvalidParameterException.ParameterName">
            <summary>Gets the name of the parameter that could not be deserialized.</summary>
        </member>
        <member name="T:RT.Servers.AjaxInvalidParameterDataException">
            <summary>Indicates that, during processing of an AJAX request, the data containing the method parameters could not be parsed.</summary>
        </member>
        <member name="M:RT.Servers.AjaxInvalidParameterDataException.#ctor(System.String)">
            <summary>
                Constructor.</summary>
            <param name="parameterData">
                The raw data that could not be parsed.</param>
        </member>
        <member name="M:RT.Servers.AjaxInvalidParameterDataException.#ctor(System.String,System.String)">
            <summary>
                Constructor.</summary>
            <param name="parameterData">
                The raw data that could not be parsed.</param>
            <param name="message">
                Exception message.</param>
        </member>
        <member name="M:RT.Servers.AjaxInvalidParameterDataException.#ctor(System.String,System.Exception)">
            <summary>
                Constructor.</summary>
            <param name="parameterData">
                The raw data that could not be parsed.</param>
            <param name="inner">
                Inner exception.</param>
        </member>
        <member name="M:RT.Servers.AjaxInvalidParameterDataException.#ctor(System.String,System.String,System.Exception)">
            <summary>
                Constructor.</summary>
            <param name="parameterData">
                The raw data that could not be parsed.</param>
            <param name="message">
                Exception message.</param>
            <param name="inner">
                Inner exception.</param>
        </member>
        <member name="P:RT.Servers.AjaxInvalidParameterDataException.ParameterData">
            <summary>Gets the raw data that could not be parsed.</summary>
        </member>
        <member name="T:RT.Servers.AjaxInvalidReturnValueException">
            <summary>Indicates that the value returned by an AJAX method could not be serialized.</summary>
        </member>
        <member name="M:RT.Servers.AjaxInvalidReturnValueException.#ctor(System.Object,System.Type)">
            <summary>
                Constructor.</summary>
            <param name="returnValue">
                The return value that could not be serialized.</param>
            <param name="returnType">
                The return type of the relevant AJAX method.</param>
        </member>
        <member name="M:RT.Servers.AjaxInvalidReturnValueException.#ctor(System.Object,System.Type,System.String)">
            <summary>
                Constructor.</summary>
            <param name="returnValue">
                The return value that could not be serialized.</param>
            <param name="returnType">
                The return type of the relevant AJAX method.</param>
            <param name="message">
                Exception message.</param>
        </member>
        <member name="M:RT.Servers.AjaxInvalidReturnValueException.#ctor(System.Object,System.Type,System.Exception)">
            <summary>
                Constructor.</summary>
            <param name="returnValue">
                The return value that could not be serialized.</param>
            <param name="returnType">
                The return type of the relevant AJAX method.</param>
            <param name="inner">
                Inner exception.</param>
        </member>
        <member name="M:RT.Servers.AjaxInvalidReturnValueException.#ctor(System.Object,System.Type,System.String,System.Exception)">
            <summary>
                Constructor.</summary>
            <param name="returnValue">
                The return value that could not be serialized.</param>
            <param name="returnType">
                The return type of the relevant AJAX method.</param>
            <param name="message">
                Exception message.</param>
            <param name="inner">
                Inner exception.</param>
        </member>
        <member name="P:RT.Servers.AjaxInvalidReturnValueException.ReturnValue">
            <summary>Gets the return value that could not be serialized.</summary>
        </member>
        <member name="P:RT.Servers.AjaxInvalidReturnValueException.ReturnType">
            <summary>Gets the return type of the relevant AJAX method.</summary>
        </member>
        <member name="T:RT.Servers.AjaxMethodAttribute">
            <summary>Specifies that a method can be called via AJAX using an <see cref="T:RT.Servers.AjaxHandler`1"/>.</summary>
        </member>
        <member name="T:RT.Servers.Authenticator">
            <summary>Provides functionality for a login system.</summary>
        </member>
        <member name="M:RT.Servers.Authenticator.#ctor(System.Func{RT.Servers.IHttpUrl,System.String},System.String)">
            <summary>
                Constructor.</summary>
            <param name="defaultReturnTo">
                Default URL to redirect to when a login attempt is successful. This can be overridden by a "returnto" GET
                parameter.</param>
            <param name="appName">
                Name of the application which uses this authentication handler.</param>
        </member>
        <member name="M:RT.Servers.Authenticator.Handle(RT.Servers.HttpRequest,System.String,System.Action{System.String})">
            <summary>
                Handles a request.</summary>
            <param name="request">
                Request to handle.</param>
            <param name="setUsername">
                Action to call when login is successful. Typically used to set the username in a session.</param>
            <param name="loggedInUser">
                Username of the user currently logged in (typically read from a session).</param>
        </member>
        <member name="M:RT.Servers.Authenticator.CreateUser(System.String,System.String,System.Boolean)">
            <summary>
                Creates a new user. (Throws if the <paramref name="username"/> is already in use.)</summary>
            <param name="username">
                Username of the new user.</param>
            <param name="password">
                Password for the new user.</param>
            <param name="canCreateUsers">
                Indicates whether the new user should have the right to create new users.</param>
            <exception cref="T:System.InvalidOperationException">
                The specified username is already in use.</exception>
        </member>
        <member name="M:RT.Servers.Authenticator.getUser(System.String@,System.String@,System.Boolean@)">
            <summary>
                When overridden in a derived class, retrieves the username and password hash of a user.</summary>
            <param name="username">
                Identifies the user to be verified, and passes out the user’s correct username. (For example, if usernames are
                case-insensitive, the name is changed to the correct capitalization.)</param>
            <param name="passwordHash">
                Receives the password hash for the user.</param>
            <param name="canCreateUsers">
                Receives a value indicating whether this user has the right to create new users.</param>
            <returns>
                <c>true</c> if the user exists; <c>false</c> otherwise.</returns>
            <remarks>
                If the user does not exist, the overridden method must return <c>false</c> and not modify <paramref
                name="username"/>.</remarks>
        </member>
        <member name="M:RT.Servers.Authenticator.changePassword(System.String,System.String,System.Func{System.String,System.Boolean})">
            <summary>
                When overridden in a derived class, attempts to change a user’s password.</summary>
            <param name="username">
                The user whose password is to be changed.</param>
            <param name="newPasswordHash">
                The new password hash for the user.</param>
            <param name="verifyOldPasswordHash">
                A function which, if not <c>null</c>, must be called to verify that the old password is valid.</param>
            <returns>
                <c>true</c> if the password was successfully changed; <c>false</c> if the specified user does not exist or
                <paramref name="verifyOldPasswordHash"/> returned <c>false</c> indicating that the old password hash turned
                out to be invalid.</returns>
        </member>
        <member name="M:RT.Servers.Authenticator.createUser(System.String,System.String,System.Boolean)">
            <summary>
                When overridden in a derived class, creates a new user.</summary>
            <param name="username">
                Username for the new user.</param>
            <param name="passwordHash">
                Hashed password for the new user.</param>
            <param name="canCreateUsers">
                Specifies whether the new user has the right to create new users.</param>
            <returns>
                <c>true</c> if a new user was created; <c>false</c> if <paramref name="username"/> is already taken.</returns>
        </member>
        <member name="T:RT.Servers.FileAuthenticator">
            <summary>Provides functionality for a login system.</summary>
        </member>
        <member name="F:RT.Servers.FileAuthenticator._lock">
            <summary>
                Used to ensure that the AuthUsers XML file is not read and written concurrently.</summary>
            <remarks>
                static in case multiple instances of <see cref="T:RT.Servers.FileAuthenticator"/> use the same XML file.</remarks>
        </member>
        <member name="M:RT.Servers.FileAuthenticator.#ctor(System.String,System.Func{RT.Servers.IHttpUrl,System.String},System.String)">
            <summary>
                Constructor.</summary>
            <param name="usersFilePath">
                Specifies the path and filename of an XML file containing the users and passwords.</param>
            <param name="defaultReturnTo">
                Default URL to redirect to when a login attempt is successful. This can be overridden by a "returnto" GET
                parameter.</param>
            <param name="appName">
                Name of the application which uses this authentication handler.</param>
        </member>
        <member name="M:RT.Servers.FileAuthenticator.getUser(System.String@,System.String@,System.Boolean@)">
            <summary>See base.</summary>
        </member>
        <member name="M:RT.Servers.FileAuthenticator.changePassword(System.String,System.String,System.Func{System.String,System.Boolean})">
            <summary>See base.</summary>
        </member>
        <member name="M:RT.Servers.FileAuthenticator.createUser(System.String,System.String,System.Boolean)">
            <summary>See base.</summary>
        </member>
        <member name="T:RT.Servers.Communicator">
            <summary>
                Provides functionality to host objects on a remote server, and to access them from a client via a transparent proxy
                object.</summary>
        </member>
        <member name="M:RT.Servers.Communicator.CreateHandlerFromFactory``1(``0)">
            <summary>
                Creates an HTTP request handler that responds to requests from clients to execute methods on the specified factory
                object as well as any remote objects generated from it.</summary>
            <typeparam name="T">
                The type containing the factory methods. If the client is going to access the factory methods via an interface,
                this should be that interface type rather than the concrete type of <paramref name="factoryInstance"/>.</typeparam>
            <param name="factoryInstance">
                An instance that implements or derives from <typeparamref name="T"/> which provides the factory functionality to
                be accessed by clients.</param>
            <returns>
                An HTTP handler that can be used in <see cref="T:RT.Servers.HttpServer"/> or <see cref="T:RT.Servers.UrlResolver"/>.</returns>
        </member>
        <member name="M:RT.Servers.Communicator.CreateFactory``1(System.String)">
            <summary>
                Returns an object of the specified type which can remotely access factory methods at the specified URL.</summary>
            <typeparam name="T">
                Type of the factory interface.</typeparam>
            <param name="url">
                URL at which an HTTP server is handling Communicator requests for the required object.</param>
            <returns>
                A transparent proxy for the requested remote factory object.</returns>
        </member>
        <member name="T:RT.Servers.RemoteAttribute">
            <summary>
                Indicates that the value returned by a method return value or <c>out</c> or <c>ref</c> parameter should be treated as
                a new remote object managed by <see cref="T:RT.Servers.Communicator"/>. (Without this attribute, the default behavior is to
                serialize the object.)</summary>
        </member>
        <member name="T:RT.Servers.FileSystemHandler">
            <summary>Provides a handler for <see cref="T:RT.Servers.HttpServer"/> that can return files and list the contents of directories on the local file system.</summary>
        </member>
        <member name="M:RT.Servers.FileSystemHandler.#ctor(System.String,RT.Servers.FileSystemOptions)">
            <summary>Initializes a new instance of <see cref="T:RT.Servers.FileSystemHandler"/>.</summary>
            <param name="baseDir">Specifies the directory in the local file system from which files are served and directory contents are listed.</param>
            <param name="options">Specifies the options associated with this instance, or null to use the <see cref="P:RT.Servers.FileSystemHandler.DefaultOptions"/>.</param>
        </member>
        <member name="M:RT.Servers.FileSystemHandler.Handle(RT.Servers.HttpRequest)">
            <summary>Returns an <see cref="T:RT.Servers.HttpResponse"/> that handles the specified request, either by delivering a file from the local file system,
            or by listing the contents of a directory in the local file system. The file or directory served is determined from the configured
            <see cref="P:RT.Servers.FileSystemHandler.BaseDirectory"/> and the <see cref="P:RT.Servers.HttpRequest.Url"/> of the specified <paramref name="request"/>.</summary>
            <param name="request">HTTP request from the client.</param>
            <returns>An <see cref="T:RT.Servers.HttpResponse"/> encapsulating the file transfer or directory listing.</returns>
        </member>
        <member name="F:RT.Servers.FileSystemHandler._directoryListingXslString">
            <summary>
            XSL to use for directory listings. This will be converted to UTF-8, whitespace-optimised and cached before being output.
            This is the file that is returned at the URL /$/directory-listing/xsl.
            </summary>
        </member>
        <member name="F:RT.Servers.FileSystemHandler._directoryListingXslByteArray">
            <summary>
            Caches the UTF-8-encoded version of the directory-listing XSL file.
            </summary>
        </member>
        <member name="M:RT.Servers.FileSystemHandler.GetDirectoryListingIcon(System.String)">
            <summary>
            Returns a byte array representing an icon in PNG format that corresponds to the specified file extension.
            </summary>
            <param name="extension">The file extension for which to retrieve an icon in PNG format.</param>
            <returns>A byte array representing an icon in PNG format that corresponds to the specified file extension.</returns>
        </member>
        <member name="M:RT.Servers.FileSystemHandler.GetDirectoryListingIconStr(System.String)">
            <summary>
            Returns a file extension whose icon is used in directory listings to represent files of the specified file extension.
            </summary>
            <param name="extension">The extension of the actual file for which to display an icon.</param>
            <returns>The file extension whose icon is used in directory listings to represent files of the specified file extension.</returns>
        </member>
        <member name="P:RT.Servers.FileSystemHandler.DefaultOptions">
            <summary>Specifies the default options to fall back to whenever an instance of this class has no options of its own.</summary>
        </member>
        <member name="P:RT.Servers.FileSystemHandler.Options">
            <summary>Specifies the options associated with this instance, or null to use the <see cref="P:RT.Servers.FileSystemHandler.DefaultOptions"/>.</summary>
        </member>
        <member name="P:RT.Servers.FileSystemHandler.BaseDirectory">
            <summary>Specifies the directory in the local file system from which files are served and directory contents are listed.</summary>
        </member>
        <member name="P:RT.Servers.FileSystemHandler.DirectoryListingXsl">
            <summary>Returns a byte array containing the UTF-8-encoded directory-listing XSL.</summary>
            <returns>A byte array containing the UTF-8-encoded directory-listing XSL.</returns>
        </member>
        <member name="T:RT.Servers.FileSystemOptions">
            <summary>Contains configuration settings for a <see cref="T:RT.Servers.FileSystemHandler"/>.</summary>
        </member>
        <member name="F:RT.Servers.FileSystemOptions.MimeTypeOverrides">
            <summary>Maps from file extension to MIME type. Use the key "*" to specify a default (fallback) MIME type.
            Use the value "detect" to specify that <see cref="T:RT.Servers.FileSystemHandler"/> should examine the file and decide between
            "text/plain; charset=utf-8" and "application/octet-stream", depending on whether the file is text or binary.</summary>
        </member>
        <member name="M:RT.Servers.FileSystemOptions.GetDefaultMimeType(System.String)">
            <summary>Returns a default MIME type for the specified extension.</summary>
        </member>
        <member name="M:RT.Servers.FileSystemOptions.GetMimeType(System.String)">
            <summary>Returns the MIME type for the specified local file.</summary>
        </member>
        <member name="F:RT.Servers.FileSystemOptions.DirectoryListingStyle">
            <summary>
            Specifies which way directory listings should be generated. Default is <see cref="F:RT.Servers.DirectoryListingStyle.XmlPlusXsl"/>.
            </summary>
        </member>
        <member name="F:RT.Servers.FileSystemOptions.MaxAge">
            <summary>
            Specifies the value for the CacheControl max-age header on the files served by the file system handler, in seconds. Set to null to prevent this header being
            sent, which will result in the browser revalidating the file on every request. The If-Modified-Since mechanism is always used regardless of this setting.
            </summary>
        </member>
        <member name="T:RT.Servers.DirectoryListingStyle">
            <summary>Controls which style of directory listing should be used by <see cref="T:RT.Servers.FileSystemHandler"/> to list the contents of directories.</summary>
        </member>
        <member name="F:RT.Servers.DirectoryListingStyle.Forbidden">
            <summary>Specifies that directory listing is forbidden (returns a 401 Unauthorised error).</summary>
        </member>
        <member name="F:RT.Servers.DirectoryListingStyle.XmlPlusXsl">
            <summary>Specifies a directory style that uses an XML file with an XSL style sheet.</summary>
        </member>
        <member name="T:RT.Servers.HttpEndpoint">
            <summary>Contains endpoint information that specifies where the HTTP server will listen for incoming connections.</summary>
        </member>
        <member name="M:RT.Servers.HttpEndpoint.#ctor(System.String,System.Int32,System.Boolean)">
            <summary>
                Creates an instance of HttpEndpoint.</summary>
            <param name="bindAddress">
                The hostname/address to listen on, or null to listen on all interfaces.</param>
            <param name="port">
                The port to listen on.</param>
            <param name="secure">
                Specifies whether this is a secure (HTTPS) endpoint.</param>
        </member>
        <member name="M:RT.Servers.HttpEndpoint.Equals(RT.Servers.HttpEndpoint)">
            <summary>
                Compares two <see cref="T:RT.Servers.HttpEndpoint"/> objects for equality.</summary>
            <param name="other">
                The other object to compare against.</param>
        </member>
        <member name="M:RT.Servers.HttpEndpoint.ToString">
            <summary>Returns a human-readable representation of this endpoint.</summary>
        </member>
        <member name="M:RT.Servers.HttpEndpoint.GetHashCode">
            <summary>Returns a hash value for this object.</summary>
        </member>
        <member name="P:RT.Servers.HttpEndpoint.BindAddress">
            <summary>
                The IP address of the interface to which the HTTP server should bind, or <c>null</c> to let the server listen
                on all network interfaces.</summary>
            <remarks>
                This is a string rather than System.Net.IPAddress so that Classify can serialize it. If the contents don’t
                parse, <c>null</c> is assumed.</remarks>
        </member>
        <member name="P:RT.Servers.HttpEndpoint.Port">
            <summary>The port on which the server should listen for connections.</summary>
        </member>
        <member name="P:RT.Servers.HttpEndpoint.Secure">
            <summary>
                Specifies whether this should be a secured (HTTPS) connection. The X509 certificate defined in the <see cref="T:RT.Servers.HttpServerOptions"/> must not be <c>null</c>.</summary>
        </member>
        <member name="T:RT.Servers.HttpProtocolVersion">
            <summary>Contains values for the supported HTTP protocol versions.</summary>
        </member>
        <member name="T:RT.Servers.HttpMethod">
            <summary>Contains values for the supported HTTP methods.</summary>
        </member>
        <member name="T:RT.Servers.HttpAcceptRanges">
            <summary>Contains values for the supported values of the Accept-Ranges HTTP request header.</summary>
        </member>
        <member name="T:RT.Servers.HttpConnection">
            <summary>Contains values for the supported values of the Connection HTTP request or response header.</summary>
        </member>
        <member name="T:RT.Servers.HttpCacheControlState">
            <summary>Contains values for the Cache-Control HTTP request or response header. None of these currently have any effect.</summary>
        </member>
        <member name="T:RT.Servers.HttpContentDispositionMode">
            <summary>
            Contains values for the supported values of the Content-Disposition HTTP entity header, minus the filename.
            </summary>
            <seealso cref="T:RT.Servers.HttpContentDisposition"/>
        </member>
        <member name="T:RT.Servers.HttpContentEncoding">
            <summary>
            Contains values for the supported values of the Accept-Encoding HTTP request header and the Content-Encoding HTTP response header.
            </summary>
        </member>
        <member name="T:RT.Servers.HttpTransferEncoding">
            <summary>
            Contains values for the supported values of the Transfer-Encoding HTTP response header.
            </summary>
        </member>
        <member name="T:RT.Servers.HttpPostContentType">
            <summary>
            Contains values for the supported values of the Content-Type HTTP request header when used in HTTP POST requests.
            </summary>
        </member>
        <member name="T:RT.Servers.HttpEnumsParser">
            <summary>
            Implements parse routines for the HttpEnums. These routines are preferred to <see cref="M:System.Enum.Parse(System.Type,System.String)"/>
            because no reflection is involved.
            </summary>
        </member>
        <member name="M:RT.Servers.HttpEnumsParser.ParseHttpContentEncoding(System.String)">
            <summary>
            Parses the Content-Encoding header. Returns null if the value is not valid.
            </summary>
        </member>
        <member name="M:RT.Servers.HttpEnumsParser.ParseHttpConnection(System.String)">
            <summary>
            Parses the Connection header. Throws an exception if the value is not valid.
            As long as exactly one of the valid values is contained in a comma-separated version returns the value
            and ignores all other values.
            </summary>
        </member>
        <member name="T:RT.Servers.UseGzipOption">
            <summary>
            Contains possible values for the <see cref="F:RT.Servers.HttpResponseContent.UseGzip"/> option.
            </summary>
        </member>
        <member name="F:RT.Servers.UseGzipOption.AutoDetect">
            <summary>
            Specifies that the server should look at a chunk in the middle of the file to determine whether it is worth gzipping.
            </summary>
        </member>
        <member name="F:RT.Servers.UseGzipOption.DontUseGzip">
            <summary>
            Specifies not to use gzip for this response.
            </summary>
        </member>
        <member name="F:RT.Servers.UseGzipOption.AlwaysUseGzip">
            <summary>
            Specifies to use gzip (if the client requested it).
            </summary>
        </member>
        <member name="T:RT.Servers.Protocols">
            <summary>
            Specifies possible protocols to hook to in a <see cref="T:RT.Servers.UrlHook"/>.
            </summary>
        </member>
        <member name="F:RT.Servers.Protocols.None">
            <summary>The hook will never match.</summary>
        </member>
        <member name="F:RT.Servers.Protocols.Http">
            <summary>The hook responds to unencrypted HTTP.</summary>
        </member>
        <member name="F:RT.Servers.Protocols.Https">
            <summary>The hook responds to HTTP encrypted via an SSL transport layer.</summary>
        </member>
        <member name="F:RT.Servers.Protocols.All">
            <summary>The hook responds to all supported protocols.</summary>
        </member>
        <member name="T:RT.Servers.HttpException">
            <summary>Provides an exception that carries an HTTP status code.</summary>
        </member>
        <member name="M:RT.Servers.HttpException.#ctor(RT.Servers.HttpStatusCode,System.String,System.String)">
            <summary>
                Constructor.</summary>
            <param name="statusCode">
                The status code associated with this exception.</param>
            <param name="message">
                An optional exception message. If omitted, the <paramref name="userMessage"/> will be used.</param>
            <param name="userMessage">
                An optional error message which may be revealed to the user. If omitted, a default status code description
                will be used.</param>
        </member>
        <member name="M:RT.Servers.HttpException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>Constructor for serialization.</summary>
        </member>
        <member name="M:RT.Servers.HttpException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>Override for serialization.</summary>
        </member>
        <member name="P:RT.Servers.HttpException.StatusCode">
            <summary>The status code associated with this exception.</summary>
        </member>
        <member name="P:RT.Servers.HttpException.UserMessage">
            <summary>An error message which may be revealed to the user.</summary>
        </member>
        <member name="T:RT.Servers.HttpNotFoundException">
            <summary>Provides an exception that indicates that a resource was not found.</summary>
        </member>
        <member name="M:RT.Servers.HttpNotFoundException.#ctor(System.String)">
            <summary>
                Constructor.</summary>
            <param name="location">
                An optional string describing the resource that was not found. This will be revealed to the user.</param>
        </member>
        <member name="M:RT.Servers.HttpNotFoundException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>Constructor for serialization.</summary>
        </member>
        <member name="M:RT.Servers.HttpNotFoundException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>Override for serialization.</summary>
        </member>
        <member name="P:RT.Servers.HttpNotFoundException.Location">
            <summary>A string describing the resource that was not found. May be null.</summary>
        </member>
        <member name="T:RT.Servers.HttpRequestParseException">
            <summary>
                Indicates that an error has occurred while parsing a request. This usually indicates that the request was
                malformed in some way.</summary>
        </member>
        <member name="M:RT.Servers.HttpRequestParseException.#ctor(RT.Servers.HttpStatusCode,System.String)">
            <summary>Constructor.</summary>
        </member>
        <member name="M:RT.Servers.HttpRequestParseException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>Constructor for serialization.</summary>
        </member>
        <member name="T:RT.Servers.HttpInternalObjects">
            <summary>
            Internal class containing global static objects.
            </summary>
        </member>
        <member name="F:RT.Servers.HttpInternalObjects.StatusCodeNames">
            <summary>
            Contains string representations of the HTTP status codes defined in HTTP/1.1.
            </summary>
        </member>
        <member name="M:RT.Servers.HttpInternalObjects.RandomTempFilepath(System.String,System.IO.Stream@)">
            <summary>
            Generates a random filename for a temporary file in the specified directory.
            </summary>
            <param name="tempDir">Directory to generate a temporary file in.</param>
            <param name="fStream">Will be set to a writable FileStream pointing at the newly-created, empty temporary file.</param>
            <returns>The full path and filename of the temporary file.</returns>
        </member>
        <member name="T:RT.Servers.HttpRequest">
            <summary>
            Encapsulates an HTTP request, including its method, URL and headers. <see cref="T:RT.Servers.HttpServer"/> generates this when it receives an
            HTTP request and passes it to the relevant request handler.
            </summary>
        </member>
        <member name="F:RT.Servers.HttpRequest.CleanUpCallback">
            <summary>Specifies an action to perform when the request finishes.</summary>
            <remarks>Use <c>+=</c> to add cleanup actions so as to not overwrite existing ones.</remarks>
        </member>
        <member name="M:RT.Servers.HttpRequest.#ctor">
            <summary>
            A default constructor that initialises all fields to their defaults.
            </summary>
        </member>
        <member name="M:RT.Servers.HttpRequest.#ctor(RT.Servers.HttpRequest)">
            <summary>Initialises this HTTP request from the specified HTTP request.</summary>
        </member>
        <member name="M:RT.Servers.HttpRequest.ParsePostBody(System.IO.Stream,System.String,System.Int64)">
            <summary>If this request is a POST request, replaces the body of the request with data from the specified stream.
            This will clear and reinitialise all the POST parameter values and file uploads.</summary>
            <param name="body">Stream to read new POST request body from.</param>
            <param name="tempPath">The temporary directory to use for file uploads. Default is <see cref="M:System.IO.Path.GetTempPath"/>.</param>
            <param name="storeFileUploadInFileAtSize">The maximum size (in bytes) at which file uploads are stored in memory.
            Any uploads that exceed this limit are written to temporary files on disk. Default is 16 MB.</param>
        </member>
        <member name="P:RT.Servers.HttpRequest.Url">
            <summary>Specifies the URL requested, including information about how this location is resolved by the handlers (if any).</summary>
        </member>
        <member name="P:RT.Servers.HttpRequest.HttpVersion">
            <summary>Specifies the HTTP protocol version that was used for this request.</summary>
        </member>
        <member name="P:RT.Servers.HttpRequest.Method">
            <summary>Specifies the HTTP request method (GET, POST or HEAD) that was used for this request.</summary>
        </member>
        <member name="P:RT.Servers.HttpRequest.Headers">
            <summary>Contains the HTTP request headers that were received and understood by <see cref="T:RT.Servers.HttpServer"/>.</summary>
        </member>
        <member name="P:RT.Servers.HttpRequest.ClientIPAddress">
            <summary>Identifies the client that sent this request.</summary>
        </member>
        <member name="P:RT.Servers.HttpRequest.SourceIP">
            <summary>Identifies the immediate source of this request, which might be the client itself, or an HTTP proxy.</summary>
        </member>
        <member name="P:RT.Servers.HttpRequest.Data">
            <summary>Not used by <see cref="T:RT.Servers.HttpServer"/> in any way, this field may be used by the application to store any relevant information.</summary>
        </member>
        <member name="P:RT.Servers.HttpRequest.Post">
            <summary>
            Provides access to POST query parameters (empty if the request is not a POST request).
            </summary>
        </member>
        <member name="P:RT.Servers.HttpRequest.FileUploads">
            <summary>
            Contains information about file uploads included in a POST request. Empty if the request is not a POST request.
            </summary>
        </member>
        <member name="T:RT.Servers.HttpResponse">
            <summary>
                Encapsulates a response to an HTTP request. Concrete classes implementing this are <see cref="T:RT.Servers.HttpResponseContent"/> and <see cref="T:RT.Servers.HttpResponseWebSocket"/>.</summary>
        </member>
        <member name="M:RT.Servers.HttpResponse.#ctor(RT.Servers.HttpResponseHeaders)">
            <summary>Constructor.</summary>
        </member>
        <member name="M:RT.Servers.HttpResponse.GetContentStream">
            <summary>Returns <c>null</c>. Overridden only by <see cref="T:RT.Servers.HttpResponseContent"/>.</summary>
        </member>
        <member name="M:RT.Servers.HttpResponse.File(System.String,System.String,System.Nullable{System.Int32},System.Nullable{System.DateTime})">
            <summary>
                Returns the specified file from the local file system using the specified MIME content type to the client.</summary>
            <param name="filePath">
                Full path and filename of the file to return.</param>
            <param name="contentType">
                MIME type to use in the Content-Type header. If null, the first kilobyte will be looked at to choose between
                the plaintext and the octet-stream content type.</param>
            <param name="maxAge">
                Specifies the value for the CacheControl max-age header on the file served. Set to null to prevent this header
                being sent.</param>
            <param name="ifModifiedSince">
                If specified, a 304 Not Modified will be served if the file's last modified timestamp is at or before this
                time.</param>
        </member>
        <member name="M:RT.Servers.HttpResponse.Redirect(System.String)">
            <summary>
                Redirects the client to a new URL, using the HTTP status code 302 Found and making the response uncacheable.</summary>
            <param name="newUrl">
                URL to redirect the client to.</param>
        </member>
        <member name="M:RT.Servers.HttpResponse.Redirect(RT.Servers.IHttpUrl)">
            <summary>
                Redirects the client to a new URL, using the HTTP status code 302 Found and making the response uncacheable.</summary>
            <param name="newUrl">
                URL to redirect the client to.</param>
        </member>
        <member name="M:RT.Servers.HttpResponse.NotModified">
            <summary>Generates a 304 Not Modified response.</summary>
        </member>
        <member name="M:RT.Servers.HttpResponse.Empty(RT.Servers.HttpStatusCode,RT.Servers.HttpResponseHeaders)">
            <summary>
                Returns a response to the client consisting of an empty body.</summary>
            <param name="status">
                HTTP status code to use in the response.</param>
            <param name="headers">
                Headers to use in the response, or null to use default values.</param>
        </member>
        <member name="M:RT.Servers.HttpResponse.Html(RT.TagSoup.Tag,RT.Servers.HttpStatusCode,RT.Servers.HttpResponseHeaders,System.Boolean)">
            <summary>
                Returns the specified tag content to the client.</summary>
            <param name="content">
                Content to return to the client.</param>
            <param name="status">
                HTTP status code to use in the response.</param>
            <param name="headers">
                Headers to use in the response, or null to use default values.</param>
            <param name="buffered">
                If true (default), the output is buffered for performance; otherwise, all text is transmitted as soon as
                possible.</param>
        </member>
        <member name="M:RT.Servers.HttpResponse.Html(System.String,RT.Servers.HttpStatusCode,RT.Servers.HttpResponseHeaders)">
            <summary>
                Returns the specified content to the client with the MIME type “text/html; charset=utf-8”.</summary>
            <param name="content">
                Content to return to the client.</param>
            <param name="status">
                HTTP status code to use in the response.</param>
            <param name="headers">
                Headers to use in the response, or null to use default values.</param>
        </member>
        <member name="M:RT.Servers.HttpResponse.Html(System.Collections.Generic.IEnumerable{System.String},RT.Servers.HttpStatusCode,RT.Servers.HttpResponseHeaders,System.Boolean)">
            <summary>
                Returns the specified content to the client as a single concatenated piece of text with the MIME type
                “text/html; charset=utf-8”.</summary>
            <param name="content">
                Content to return to the client.</param>
            <param name="status">
                HTTP status code to use in the response.</param>
            <param name="headers">
                Headers to use in the response, or null to use default values.</param>
            <param name="buffered">
                If true (default), the output is buffered for performance; otherwise, all text is transmitted as soon as
                possible.</param>
        </member>
        <member name="M:RT.Servers.HttpResponse.Html(System.Byte[],RT.Servers.HttpStatusCode,RT.Servers.HttpResponseHeaders)">
            <summary>
                Returns the contents of the specified byte array to the client.</summary>
            <param name="content">
                Content to return to the client.</param>
            <param name="status">
                HTTP status code to use in the response.</param>
            <param name="headers">
                Headers to use in the response, or null to use default values.</param>
        </member>
        <member name="M:RT.Servers.HttpResponse.Html(System.IO.Stream,RT.Servers.HttpStatusCode,RT.Servers.HttpResponseHeaders)">
            <summary>
                Returns the contents of the specified stream to the client.</summary>
            <param name="content">
                Content to return to the client.</param>
            <param name="status">
                HTTP status code to use in the response.</param>
            <param name="headers">
                Headers to use in the response, or null to use default values.</param>
        </member>
        <member name="M:RT.Servers.HttpResponse.PlainText(System.String,RT.Servers.HttpStatusCode,RT.Servers.HttpResponseHeaders)">
            <summary>
                Returns the specified content to the client with the MIME type “text/plain; charset=utf-8”.</summary>
            <param name="content">
                Content to return to the client.</param>
            <param name="status">
                HTTP status code to use in the response.</param>
            <param name="headers">
                Headers to use in the response, or null to use default values.</param>
        </member>
        <member name="M:RT.Servers.HttpResponse.PlainText(System.Collections.Generic.IEnumerable{System.String},RT.Servers.HttpStatusCode,RT.Servers.HttpResponseHeaders,System.Boolean)">
            <summary>
                Returns the specified content to the client as a single concatenated piece of text with the MIME type
                “text/plain; charset=utf-8”.</summary>
            <param name="content">
                Content to return to the client.</param>
            <param name="status">
                HTTP status code to use in the response.</param>
            <param name="headers">
                Headers to use in the response, or null to use default values.</param>
            <param name="buffered">
                If true (default), the output is buffered for performance; otherwise, all text is transmitted as soon as
                possible.</param>
        </member>
        <member name="M:RT.Servers.HttpResponse.PlainText(System.Byte[],RT.Servers.HttpStatusCode,RT.Servers.HttpResponseHeaders)">
            <summary>
                Returns the contents of the specified byte array to the client.</summary>
            <param name="content">
                Content to return to the client.</param>
            <param name="status">
                HTTP status code to use in the response.</param>
            <param name="headers">
                Headers to use in the response, or null to use default values.</param>
        </member>
        <member name="M:RT.Servers.HttpResponse.PlainText(System.IO.Stream,RT.Servers.HttpStatusCode,RT.Servers.HttpResponseHeaders)">
            <summary>
                Returns the contents of the specified stream to the client.</summary>
            <param name="content">
                Content to return to the client.</param>
            <param name="status">
                HTTP status code to use in the response.</param>
            <param name="headers">
                Headers to use in the response, or null to use default values.</param>
        </member>
        <member name="M:RT.Servers.HttpResponse.JavaScript(System.String,RT.Servers.HttpStatusCode,RT.Servers.HttpResponseHeaders)">
            <summary>
                Returns the specified content to the client with the MIME type “text/javascript; charset=utf-8”.</summary>
            <param name="content">
                Content to return to the client.</param>
            <param name="status">
                HTTP status code to use in the response.</param>
            <param name="headers">
                Headers to use in the response, or null to use default values.</param>
        </member>
        <member name="M:RT.Servers.HttpResponse.JavaScript(System.Collections.Generic.IEnumerable{System.String},RT.Servers.HttpStatusCode,RT.Servers.HttpResponseHeaders,System.Boolean)">
            <summary>
                Returns the specified content to the client as a single concatenated piece of text with the MIME type
                “text/javascript; charset=utf-8”.</summary>
            <param name="content">
                Content to return to the client.</param>
            <param name="status">
                HTTP status code to use in the response.</param>
            <param name="headers">
                Headers to use in the response, or null to use default values.</param>
            <param name="buffered">
                If true (default), the output is buffered for performance; otherwise, all text is transmitted as soon as
                possible.</param>
        </member>
        <member name="M:RT.Servers.HttpResponse.JavaScript(System.Byte[],RT.Servers.HttpStatusCode,RT.Servers.HttpResponseHeaders)">
            <summary>
                Returns the contents of the specified byte array to the client.</summary>
            <param name="content">
                Content to return to the client.</param>
            <param name="status">
                HTTP status code to use in the response.</param>
            <param name="headers">
                Headers to use in the response, or null to use default values.</param>
        </member>
        <member name="M:RT.Servers.HttpResponse.JavaScript(System.IO.Stream,RT.Servers.HttpStatusCode,RT.Servers.HttpResponseHeaders)">
            <summary>
                Returns the contents of the specified stream to the client.</summary>
            <param name="content">
                Content to return to the client.</param>
            <param name="status">
                HTTP status code to use in the response.</param>
            <param name="headers">
                Headers to use in the response, or null to use default values.</param>
        </member>
        <member name="M:RT.Servers.HttpResponse.Json(RT.Util.Json.JsonValue,RT.Servers.HttpStatusCode,RT.Servers.HttpResponseHeaders)">
            <summary>
                Returns the specified content to the client with the MIME type “application/json; charset=utf-8”.</summary>
            <param name="content">
                Content to return to the client.</param>
            <param name="status">
                HTTP status code to use in the response.</param>
            <param name="headers">
                Headers to use in the response, or null to use default values.</param>
        </member>
        <member name="M:RT.Servers.HttpResponse.Css(System.String,RT.Servers.HttpStatusCode,RT.Servers.HttpResponseHeaders)">
            <summary>
                Returns the specified content to the client with the MIME type “text/css; charset=utf-8”.</summary>
            <param name="content">
                Content to return to the client.</param>
            <param name="status">
                HTTP status code to use in the response.</param>
            <param name="headers">
                Headers to use in the response, or null to use default values.</param>
        </member>
        <member name="M:RT.Servers.HttpResponse.Css(System.Collections.Generic.IEnumerable{System.String},RT.Servers.HttpStatusCode,RT.Servers.HttpResponseHeaders,System.Boolean)">
            <summary>
                Returns the specified content to the client as a single concatenated piece of text with the MIME type
                “text/css; charset=utf-8”.</summary>
            <param name="content">
                Content to return to the client.</param>
            <param name="status">
                HTTP status code to use in the response.</param>
            <param name="headers">
                Headers to use in the response, or null to use default values.</param>
            <param name="buffered">
                If true (default), the output is buffered for performance; otherwise, all text is transmitted as soon as
                possible.</param>
        </member>
        <member name="M:RT.Servers.HttpResponse.Css(System.Byte[],RT.Servers.HttpStatusCode,RT.Servers.HttpResponseHeaders)">
            <summary>
                Returns the contents of the specified byte array to the client.</summary>
            <param name="content">
                Content to return to the client.</param>
            <param name="status">
                HTTP status code to use in the response.</param>
            <param name="headers">
                Headers to use in the response, or null to use default values.</param>
        </member>
        <member name="M:RT.Servers.HttpResponse.Css(System.IO.Stream,RT.Servers.HttpStatusCode,RT.Servers.HttpResponseHeaders)">
            <summary>
                Returns the contents of the specified stream to the client.</summary>
            <param name="content">
                Content to return to the client.</param>
            <param name="status">
                HTTP status code to use in the response.</param>
            <param name="headers">
                Headers to use in the response, or null to use default values.</param>
        </member>
        <member name="M:RT.Servers.HttpResponse.Create(System.String,System.String,RT.Servers.HttpStatusCode,RT.Servers.HttpResponseHeaders)">
            <summary>
                Returns the specified content to the client with the specified MIME type.</summary>
            <param name="content">
                Content to return to the client.</param>
            <param name="contentType">
                MIME type to use. This overrides any MIME type specified in <paramref name="headers"/> (if any).</param>
            <param name="status">
                HTTP status code to use in the response.</param>
            <param name="headers">
                Headers to use in the response, or null to use default values.</param>
        </member>
        <member name="M:RT.Servers.HttpResponse.Create(System.Collections.Generic.IEnumerable{System.String},System.String,RT.Servers.HttpStatusCode,RT.Servers.HttpResponseHeaders,System.Boolean)">
            <summary>
                Returns the specified content to the client as a single concatenated piece of text with the specified MIME
                type.</summary>
            <param name="content">
                Content to return to the client.</param>
            <param name="contentType">
                MIME type to use. This overrides any MIME type specified in <paramref name="headers"/> (if any).</param>
            <param name="status">
                HTTP status code to use in the response.</param>
            <param name="headers">
                Headers to use in the response, or null to use default values.</param>
            <param name="buffered">
                If true (default), the output is buffered for performance; otherwise, all text is transmitted as soon as
                possible.</param>
        </member>
        <member name="M:RT.Servers.HttpResponse.Create(System.Byte[],System.String,RT.Servers.HttpStatusCode,RT.Servers.HttpResponseHeaders)">
            <summary>
                Returns the contents of the specified byte array to the client with the specified MIME type.</summary>
            <param name="content">
                Content to return to the client.</param>
            <param name="contentType">
                MIME type to use. This overrides any MIME type specified in <paramref name="headers"/> (if any).</param>
            <param name="status">
                HTTP status code to use in the response.</param>
            <param name="headers">
                Headers to use in the response, or null to use default values.</param>
        </member>
        <member name="M:RT.Servers.HttpResponse.Create(System.IO.Stream,System.String,RT.Servers.HttpStatusCode,RT.Servers.HttpResponseHeaders)">
            <summary>
                Returns the contents of the specified stream to the client with the specified MIME type.</summary>
            <param name="content">
                Content to return to the client.</param>
            <param name="contentType">
                MIME type to use. This overrides any MIME type specified in <paramref name="headers"/> (if any).</param>
            <param name="status">
                HTTP status code to use in the response.</param>
            <param name="headers">
                Headers to use in the response, or null to use default values.</param>
        </member>
        <member name="M:RT.Servers.HttpResponse.WebSocket(RT.Servers.WebSocket,System.String,RT.Servers.HttpResponseHeaders)">
            <summary>
                Returns an <see cref="T:RT.Servers.HttpResponseWebSocket"/> which indicates to the client that the HTTP connection should
                switch to the WebSocket protocol.</summary>
            <param name="websocket">
                The <see cref="M:RT.Servers.HttpResponse.WebSocket(RT.Servers.WebSocket,System.String,RT.Servers.HttpResponseHeaders)"/> implementation to use for the remainder of the connection.</param>
            <param name="subprotocol">
                The server’s selection of a subprotocol, if the client specified any subprotocols in the request.</param>
            <param name="headers">
                Optional HTTP response headers.</param>
        </member>
        <member name="M:RT.Servers.HttpResponse.op_Implicit(RT.Servers.WebSocket)~RT.Servers.HttpResponse">
            <summary>
                Provides an implicit conversion from <see cref="M:RT.Servers.HttpResponse.WebSocket(RT.Servers.WebSocket,System.String,RT.Servers.HttpResponseHeaders)"/> to <see cref="T:RT.Servers.HttpResponse"/> by assuming no
                subprotocol and no extra HTTP response headers.</summary>
            <param name="websocket">
                The <see cref="M:RT.Servers.HttpResponse.WebSocket(RT.Servers.WebSocket,System.String,RT.Servers.HttpResponseHeaders)"/> implementation to use for the remainder of the connection.</param>
            <returns>
                An <see cref="T:RT.Servers.HttpResponseWebSocket"/> object.</returns>
        </member>
        <member name="P:RT.Servers.HttpResponse.Status">
            <summary>The HTTP status code. For example, 200 OK, 404 Not Found, 500 Internal Server Error. Default is 200 OK.</summary>
        </member>
        <member name="P:RT.Servers.HttpResponse.Headers">
            <summary>The HTTP response headers which are to be sent back to the HTTP client as part of this HTTP response.</summary>
        </member>
        <member name="T:RT.Servers.HttpRequestHeaders">
            <summary>
                Encapsulates all supported HTTP request headers. These will be set by the server when it receives the request.</summary>
        </member>
        <member name="M:RT.Servers.HttpRequestHeaders.parseAndAddHeader(System.String,System.String)">
            <summary>
                Parses the specified header and stores it in this instance. Returns whether the header was recognised.</summary>
            <param name="name">
                Header name</param>
            <param name="value">
                Header value</param>
        </member>
        <member name="M:RT.Servers.HttpRequestHeaders.parseAndAddCookies(System.Collections.Generic.Dictionary{System.String,RT.Servers.Cookie}@,System.String)">
            <summary>Parses the cookie header and adds the cookies to the specified cookie dictionary.</summary>
        </member>
        <member name="M:RT.Servers.HttpRequestHeaders.parseAndAddRange(System.Collections.Generic.List{RT.Servers.HttpRange}@,System.String)">
            <summary>Parses the specified Range header and adds the ranges to the specified ranges list.</summary>
        </member>
        <member name="M:RT.Servers.HttpRequestHeaders.ContainsKey(System.String)">
            <summary>Determines if the specified header is present in this collection (case-insensitive).</summary>
        </member>
        <member name="M:RT.Servers.HttpRequestHeaders.TryGetValue(System.String,System.String@)">
            <summary>Attempts to get the specified header’s value from this collection.</summary>
        </member>
        <member name="M:RT.Servers.HttpRequestHeaders.GetEnumerator">
            <summary>Enumerates all headers and values in this collection.</summary>
        </member>
        <member name="P:RT.Servers.HttpRequestHeaders.Item(System.String)">
            <summary>Gets the value of the specified header, or null if such header is not present. Setting is not supported.</summary>
        </member>
        <member name="P:RT.Servers.HttpRequestHeaders.IsReadOnly">
            <summary>Returns true.</summary>
        </member>
        <member name="P:RT.Servers.HttpRequestHeaders.Count">
            <summary>Gets the number of headers in this collection.</summary>
        </member>
        <member name="P:RT.Servers.HttpRequestHeaders.Keys">
            <summary>Gets all the header names in this collection.</summary>
        </member>
        <member name="P:RT.Servers.HttpRequestHeaders.Values">
            <summary>Gets all the header values in this collection.</summary>
        </member>
        <member name="T:RT.Servers.HttpResponseContent">
            <summary>
                Encapsulates an HTTP response, to be sent by <see cref="T:RT.Servers.HttpServer"/> to the HTTP client that sent the original
                request. A request handler must return an HttpResponse object to the <see cref="T:RT.Servers.HttpServer"/> when handling a
                request.</summary>
        </member>
        <member name="M:RT.Servers.HttpResponseContent.GetContentStream">
            <summary>Retrieves the stream object containing the response body.</summary>
        </member>
        <member name="F:RT.Servers.HttpResponseContent.UseGzip">
            <summary>Specifies whether gzip should be used.</summary>
        </member>
        <member name="M:RT.Servers.HttpResponseContent.#ctor(RT.Servers.HttpStatusCode,RT.Servers.HttpResponseHeaders,System.Func{System.IO.Stream})">
            <summary>
                Initializes an HTTP response.</summary>
            <param name="status">
                The HTTP status code to return.</param>
            <param name="headers">
                HTTP response headers to include in the response.</param>
            <param name="contentStreamDelegate">
                A delegate that generates or returns a Stream, which in turn provides the content to return as part of this
                response. Can be <c>null</c> for empty responses.</param>
        </member>
        <member name="M:RT.Servers.HttpResponseContent.Set(RT.Servers.UseGzipOption)">
            <summary>
                Modifies the <see cref="F:RT.Servers.HttpResponseContent.UseGzip"/> option in this response object and returns the same object.</summary>
            <param name="option">
                The new value for the <see cref="F:RT.Servers.HttpResponseContent.UseGzip"/> option.</param>
        </member>
        <member name="P:RT.Servers.HttpResponseContent.Status">
            <summary>The HTTP status code. For example, 200 OK, 404 Not Found, 500 Internal Server Error. Default is 200 OK.</summary>
        </member>
        <member name="T:RT.Servers.HttpResponseHeaders">
            <summary>
                Encapsulates all supported HTTP response headers. A request handler can set these appropriately to cause the
                server to emit the required headers. See Remarks for a list of headers which are set by default.</summary>
            <remarks>
                By default, ContentType is set to "text/html; charset=utf-8".</remarks>
        </member>
        <member name="F:RT.Servers.HttpResponseHeaders.AdditionalHeaders">
            <summary>Provides a means to specify HTTP headers that are not defined in this class.</summary>
        </member>
        <member name="M:RT.Servers.HttpResponseHeaders.ToString">
            <summary>
                Returns the HTTP-compliant ASCII representation of all response headers that have been set.</summary>
            <returns>
                The HTTP-compliant ASCII representation of all response headers that have been set.</returns>
        </member>
        <member name="M:RT.Servers.HttpResponseHeaders.Clone">
            <summary>Creates a shallow clone of this object.</summary>
        </member>
        <member name="T:RT.Servers.WebSocket">
            <summary>
                Provides the base class for your application to implement a WebSocket connection. Derive from this class and then
                pass an instance of your derived class to <see cref="T:RT.Servers.HttpResponseWebSocket"/>.</summary>
        </member>
        <member name="M:RT.Servers.WebSocket.InitializeLifetimeService">
            <summary>See base.</summary>
        </member>
        <member name="M:RT.Servers.WebSocket.onBeginConnection">
            <summary>
                When overridden in a derived class, handles an incoming WebSocket connection from a client.</summary>
            <remarks>
                <list type="bullet">
                    <item><description>
                        This method is called only once per instance, and it is called when the socket has switched from the
                        HTTP handshake to the WebSocket protocol.</description></item>
                    <item><description>
                        All exceptions thrown by your code are swallowed by default. Wrap your override in a try/catch in
                        order to handle or log your exceptions.</description></item></list></remarks>
        </member>
        <member name="M:RT.Servers.WebSocket.onEndConnection">
            <summary>
                When overridden in a derived class, handles the event when the current WebSocket connection is closed.</summary>
            <remarks>
                All exceptions thrown by your code are swallowed by default. Wrap your override in a try/catch in order to
                handle or log your exceptions.</remarks>
        </member>
        <member name="M:RT.Servers.WebSocket.onTextMessageReceived(System.String)">
            <summary>
                When overridden in a derived class, handles an incoming text message from the client.</summary>
            <param name="msg">
                The text message received from the client.</param>
            <remarks>
                All exceptions thrown by your code are swallowed by default. Wrap your handler in a try/catch in order to
                handle or log your exceptions.</remarks>
        </member>
        <member name="M:RT.Servers.WebSocket.onBinaryMessageReceived(System.Byte[])">
            <summary>
                When overridden in a derived class, handles an incoming binary message from the client.</summary>
            <param name="msg">
                The message received from the client.</param>
            <remarks>
                All exceptions thrown by your code are swallowed by default. Wrap your handler in a try/catch in order to
                handle or log your exceptions.</remarks>
        </member>
        <member name="M:RT.Servers.WebSocket.SendMessage(System.Byte[])">
            <summary>
                Sends a binary message to the client.</summary>
            <param name="binaryMessage">
                The binary message to send.</param>
        </member>
        <member name="M:RT.Servers.WebSocket.SendMessage(System.Collections.Generic.IEnumerable{System.Byte[]})">
            <summary>
                Sends to the client a binary message that is provided as a sequence of chunks.</summary>
            <param name="fragmentedBinaryMessage">
                The binary message to send.</param>
        </member>
        <member name="M:RT.Servers.WebSocket.SendMessage(System.String)">
            <summary>
                Sends a text message to the client.</summary>
            <param name="textMessage">
                The text message to send.</param>
        </member>
        <member name="M:RT.Servers.WebSocket.SendMessage(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
                Sends to the client a text message that is provided as a sequence of chunks.</summary>
            <param name="fragmentedTextMessage">
                The text message to send.</param>
        </member>
        <member name="M:RT.Servers.WebSocket.SendMessage(RT.Util.Json.JsonValue)">
            <summary>
                Sends a text message containing a JSON object to the client.</summary>
            <param name="json">
                The JSON object to send.</param>
        </member>
        <member name="M:RT.Servers.WebSocket.SendMessage(System.Byte,System.Byte[])">
            <summary>
                Sends a message to the client.</summary>
            <param name="opcode">
                Specifies the opcode byte in the message header. Currently the only valid values defined in the protocol are
                <c>1</c> for text messages and <c>2</c> for binary messages.</param>
            <param name="payload">
                The message to send as a sequence of bytes.</param>
        </member>
        <member name="M:RT.Servers.WebSocket.Close">
            <summary>Closes the WebSocket connection.</summary>
        </member>
        <member name="T:RT.Servers.HttpServer">
            <summary>Provides an HTTP server.</summary>
        </member>
        <member name="M:RT.Servers.HttpServer.#ctor(RT.Servers.HttpServerOptions)">
            <summary>
                Constructs an HTTP server with the specified configuration settings.</summary>
            <param name="options">
                Specifies the configuration settings to use for this <see cref="T:RT.Servers.HttpServer"/>, or null to set all
                configuration values to default values.</param>
        </member>
        <member name="M:RT.Servers.HttpServer.#ctor(System.Int32,RT.Servers.HttpServerOptions)">
            <summary>
                Constructs an HTTP server with the specified configuration settings and using the specified port number for
                unsecured HTTP traffic.</summary>
            <param name="port">
                The port number to use.</param>
            <param name="options">
                Specifies the configuration settings to use for this <see cref="T:RT.Servers.HttpServer"/>, or null to set all
                configuration values to default values.</param>
        </member>
        <member name="F:RT.Servers.HttpServer.ShutdownComplete">
            <summary>
                Wait on this event after starting the server to be notified of when the server has fully shut down. This event
                is initially un-signalled; starting the server resets it, stopping the server sets it as soon as the last
                active connection is terminated. Starting the server again before the previous shutdown is complete will
                result in this event not being raised at all for the previous shutdown.</summary>
        </member>
        <member name="M:RT.Servers.HttpServer.StopListening(System.Boolean,System.Boolean)">
            <summary>
                Shuts the HTTP server down.</summary>
            <param name="brutal">
                If true, currently executing requests will have their connections brutally closed. The server will be fully
                shut down when the method returns. If false, all idle keepalive connections will be closed but active
                connections will be allowed to end normally. In this case, use <see cref="F:RT.Servers.HttpServer.ShutdownComplete"/> to wait until
                all connections are closed.</param>
            <param name="blocking">
                If true, will only return once all connections are closed. This might take a while unless the <paramref name="brutal"/> option is true. Setting this to true is the same as waiting for <see cref="F:RT.Servers.HttpServer.ShutdownComplete"/>
                indefinitely.</param>
        </member>
        <member name="M:RT.Servers.HttpServer.StartListening(System.Boolean)">
            <summary>
                Runs the HTTP server.</summary>
            <param name="blocking">
                Normally the method will return as soon as the listening socket is open. If this parameter is set to true,
                however, this method will block and only return once the server is fully shut down by a call to <see cref="M:RT.Servers.HttpServer.StopListening(System.Boolean,System.Boolean)"/>. This is equivalent to waiting for <see cref="F:RT.Servers.HttpServer.ShutdownComplete"/> indefinitely.</param>
        </member>
        <member name="M:RT.Servers.HttpServer.HandleConnection(System.Net.Sockets.Socket,System.Boolean)">
            <summary>
                Handles an incoming connection. This function can be used to let the server handle a TCP connection that was
                received by some other component outside the HttpServer class. This function may or may not return
                immediately; some requests may, theoretically, be handled completely synchronously if all the data has already
                been received and buffered by the OS.</summary>
            <param name="incomingConnection">
                The incoming connection to process.</param>
            <param name="secure">
                True to use SSL, false otherwise.</param>
        </member>
        <member name="P:RT.Servers.HttpServer.Options">
            <summary>
                Gets or sets the configuration settings currently in effect for this server.</summary>
            <remarks>
                When set while the server is running, most of the new settings take effect immediately. The following do not:
                <see cref="P:RT.Servers.HttpServerOptions.Endpoints"/>, <see cref="F:RT.Servers.HttpServerOptions.CertificatePath"/>.</remarks>
        </member>
        <member name="P:RT.Servers.HttpServer.Stats">
            <summary>Gets an object containing various server performance statistics.</summary>
        </member>
        <member name="P:RT.Servers.HttpServer.Log">
            <summary>
                Gets or sets a logger to log all HTTP requests to.</summary>
            <remarks>
                <para>
                    Do not modify properties of the logger while the server is running as doing so is not thread-safe.
                    Reassigning a new logger, however, should be safe (as assignment is atomic).</para></remarks>
        </member>
        <member name="P:RT.Servers.HttpServer.IsListening">
            <summary>Gets a value indicating whether the server is currently running (listening).</summary>
        </member>
        <member name="P:RT.Servers.HttpServer.Handler">
            <summary>
                Specifies the HTTP request handler for this server.</summary>
            <remarks>
                Returning null from this handler is a bug, and will cause a generic 500 Internal Server Error. All exceptions
                leaving this handler will be handled by the server, unless <see cref="F:RT.Servers.HttpServerOptions.OutputExceptionInformation"/> is configured to do otherwise. All exceptions are passed
                to the <see cref="P:RT.Servers.HttpServer.ErrorHandler"/>, which may return an arbitrary response as a result. See Remarks on <see cref="P:RT.Servers.HttpServer.ErrorHandler"/> for further information.</remarks>
        </member>
        <member name="P:RT.Servers.HttpServer.ErrorHandler">
            <summary>
                Specifies a request handler that is invoked whenever <see cref="P:RT.Servers.HttpServer.Handler"/> throws an exception.</summary>
            <remarks>
                If <c>null</c>, a default handler will be used. This default handler is also used if the error handler returns
                null or throws an exception. The default error handler will use HTTP status 500 except if the <see cref="P:RT.Servers.HttpServer.Handler"/> threw an <see cref="T:RT.Servers.HttpException"/>, in which case the exception's HTTP status is used
                instead.</remarks>
        </member>
        <member name="P:RT.Servers.HttpServer.ResponseExceptionHandler">
            <summary>
                Specifies a method to be invoked whenever an exception occurs while reading from the response stream.</summary>
            <remarks>
                Regardless of what this method does, the server will close the socket, cutting off the incomplete response.</remarks>
        </member>
        <member name="P:RT.Servers.HttpServer.PropagateExceptions">
            <summary>
                Determines whether exceptions in <see cref="P:RT.Servers.HttpServer.Handler"/>, <see cref="P:RT.Servers.HttpServer.ErrorHandler"/> and the response stream get
                propagated to the debugger. Setting this to <c>true</c> will cause exceptions to bring down the server.</summary>
            <remarks>
                <para>
                    If <c>false</c>, all exceptions are handled. <see cref="T:RT.Servers.HttpException"/> determines its own HTTP response
                    status code, all other exception types lead to 500 Internal Server Error. Use this setting in RELEASE
                    mode.</para>
                <para>
                    If <c>true</c>, only <see cref="T:RT.Servers.HttpException"/> is handled. All other exceptions are left unhandled so
                    that the Visual Studio debugger is triggered when they occur, enabling debugging. Use this setting in
                    DEBUG mode only.</para></remarks>
        </member>
        <member name="M:RT.Servers.HttpServer.connectionHandler.receiveMoreHeaderData">
            <summary>
                Initiates the process of receiving more header data. Invoked whenever the header buffer is empty and we
                haven’t yet received all the headers belonging to the current request.</summary>
        </member>
        <member name="M:RT.Servers.HttpServer.connectionHandler.moreHeaderDataReceived(System.IAsyncResult)">
            <summary>
                Completes the process of receiving more header data by passing it on to <see cref="M:RT.Servers.HttpServer.connectionHandler.processHeaderData"/>
                for processing.</summary>
        </member>
        <member name="M:RT.Servers.HttpServer.connectionHandler.cleanupIfDone">
            <summary>
                Checks whether there are any outstanding async receives, and if not, cleans up / winds down this
                connection handler.</summary>
        </member>
        <member name="M:RT.Servers.HttpServer.connectionHandler.processHeaderData">
            <summary>
                Starts or continues processing of any buffered header data. If none are buffered, will instead initiate
                the reception of more header data - a process which, when complete, will call this method to process
                whatever got received.</summary>
        </member>
        <member name="T:RT.Servers.HttpServer.Statistics">
            <summary>Keeps track of and exposes getters for various server performance statistics.</summary>
        </member>
        <member name="M:RT.Servers.HttpServer.Statistics.#ctor(RT.Servers.HttpServer)">
            <summary>Constructor.</summary>
        </member>
        <member name="M:RT.Servers.HttpServer.Statistics.AddConnectionReceived">
            <summary>Used internally to count a received connection.</summary>
        </member>
        <member name="P:RT.Servers.HttpServer.Statistics.ActiveHandlers">
            <summary>
                Gets the number of connections which are currently alive, that is receiving data, waiting to receive data,
                or sending a response.</summary>
        </member>
        <member name="P:RT.Servers.HttpServer.Statistics.KeepAliveHandlers">
            <summary>
                Gets the number of request processing threads which have completed a request but are being kept alive.</summary>
        </member>
        <member name="P:RT.Servers.HttpServer.Statistics.TotalConnectionsReceived">
            <summary>Gets the total number of connections received by the server.</summary>
        </member>
        <member name="T:RT.Servers.HttpServerOptions">
            <summary>Contains configuration settings for an <see cref="T:RT.Servers.HttpServer"/>.</summary>
        </member>
        <member name="M:RT.Servers.HttpServerOptions.AddEndpoint(System.String,RT.Servers.HttpEndpoint)">
            <summary>
                Adds an endpoint for the server to listen on.</summary>
            <param name="key">
                Unique key used to identify this endpoint.</param>
            <param name="endpoint">
                The endpoint object.</param>
        </member>
        <member name="M:RT.Servers.HttpServerOptions.AddEndpoint(System.String,System.String,System.Int32,System.Boolean)">
            <summary>
                Adds an endpoint for the server to listen on.</summary>
            <param name="key">
                Unique key used to identify this endpoint.</param>
            <param name="bindAddress">
                The hostname/address to listen on, or null to listen on all interfaces.</param>
            <param name="port">
                The port to listen on.</param>
            <param name="secure">
                Specifies whether this is a secure (HTTPS) endpoint.</param>
        </member>
        <member name="M:RT.Servers.HttpServerOptions.RemoveEndpoint(System.String)">
            <summary>
                Removes an endpoint from this option class.</summary>
            <param name="key">
                The unique key used to removed from endpoint.</param>
            <returns>
                <c>true</c> if the key was removed; <c>false</c> if the key did not exist.</returns>
        </member>
        <member name="F:RT.Servers.HttpServerOptions.CertificatePath">
            <summary>
                Specifies the path and filename of the X509 certificate to use in HTTPS. Currently, only certificates not
                protected by a password are supported.</summary>
        </member>
        <member name="F:RT.Servers.HttpServerOptions.CertificatePassword">
            <summary>The password required to access the certificate in <see cref="F:RT.Servers.HttpServerOptions.CertificatePath"/>.</summary>
        </member>
        <member name="F:RT.Servers.HttpServerOptions.IdleTimeout">
            <summary>Timeout in milliseconds for idle connections. Set to 0 for no timeout. Default is 10000 (10 seconds).</summary>
        </member>
        <member name="F:RT.Servers.HttpServerOptions.MaxSizeHeaders">
            <summary>Maximum allowed size for the headers of a request, in bytes. Default is 256 KB.</summary>
        </member>
        <member name="F:RT.Servers.HttpServerOptions.MaxSizePostContent">
            <summary>Maximum allowed size for the content of a POST request, in bytes. Default is 1 GB.</summary>
        </member>
        <member name="F:RT.Servers.HttpServerOptions.StoreFileUploadInFileAtSize">
            <summary>
                The maximum size (in bytes) at which file uploads in a POST request are stored in memory. Any uploads that
                exceed this limit are written to temporary files on disk. Default is 16 MB.</summary>
        </member>
        <member name="F:RT.Servers.HttpServerOptions.GzipInMemoryUpToSize">
            <summary>
                The maximum size (in bytes) of a response at which the server will gzip the entire content in-memory (assuming
                gzip is requested in the HTTP request). Default is 1 MB. Content larger than this size will be gzipped in
                chunks (if requested).</summary>
        </member>
        <member name="F:RT.Servers.HttpServerOptions.GzipAutodetectThreshold">
            <summary>
                If a file is larger than this, then the server will read a chunk from the middle of the file and gzip it to
                determine whether gzipping the whole file is worth it. Otherwise it will default to using gzip either way.</summary>
        </member>
        <member name="F:RT.Servers.HttpServerOptions.TempDir">
            <summary>
                The temporary directory to use for file uploads in POST requests. Default is <see cref="M:System.IO.Path.GetTempPath"/>.</summary>
        </member>
        <member name="F:RT.Servers.HttpServerOptions.OutputExceptionInformation">
            <summary>
                Determines whether the default error handler outputs exception information (including a stack trace) to the
                client (browser) as HTML. The default error handler always outputs the HTTP status code description. It is
                invoked when <see cref="P:RT.Servers.HttpServer.ErrorHandler"/> is null or throws an exception.</summary>
        </member>
        <member name="F:RT.Servers.HttpServerOptions.DefaultContentType">
            <summary>Content-Type to return when handler provides none. Default is "text/html; charset=utf-8".</summary>
        </member>
        <member name="M:RT.Servers.HttpServerOptions.CheckValid">
            <summary>
                Throws an exception if the settings are invalid.</summary>
            <remarks>
                <para>
                    Possible reasons for invalid settings include:</para>
                <list type="bullet">
                    <item><description>
                        There are no endpoints.</description></item>
                    <item><description>
                        There is an endpoint with <see cref="P:RT.Servers.HttpEndpoint.Secure"/> set to <c>true</c>, but <see cref="F:RT.Servers.HttpServerOptions.CertificatePath"/> is <c>null</c>.</description></item></list></remarks>
        </member>
        <member name="P:RT.Servers.HttpServerOptions.Endpoints">
            <summary>
                A readonly dictionary of added server endpoints. See <see cref="M:RT.Servers.HttpServerOptions.AddEndpoint(System.String,System.String,System.Int32,System.Boolean)"/>, <see cref="M:RT.Servers.HttpServerOptions.AddEndpoint(System.String,RT.Servers.HttpEndpoint)"/> and <seealso cref="M:RT.Servers.HttpServerOptions.RemoveEndpoint(System.String)"/> for adding and removing things
                from this list.</summary>
        </member>
        <member name="T:RT.Servers.HttpStatusCode">
            <summary>Contains definitions for all the HTTP status codes defined in HTTP/1.1.</summary>
        </member>
        <member name="T:RT.Servers.HttpStatusCodeExtensions">
            <summary>Extension methods for <see cref="T:RT.Servers.HttpStatusCode"/>.</summary>
        </member>
        <member name="M:RT.Servers.HttpStatusCodeExtensions.ToText(RT.Servers.HttpStatusCode)">
            <summary>
                Returns a string representation of the specified HTTP status code.</summary>
            <param name="code">
                The status code to return a string representation for.</param>
            <returns>
                A string representation of the specified HTTP status code.</returns>
        </member>
        <member name="M:RT.Servers.HttpStatusCodeExtensions.MayHaveBody(RT.Servers.HttpStatusCode)">
            <summary>
                Determines whether an HTTP response with the specified <paramref name="statusCode"/> is allowed to have a body
                (i.e. a non-null content stream).</summary>
            <param name="statusCode">
                The HTTP status code to examine.</param>
            <returns>
                A boolean value that indicates whether an HTTP response with the specified <paramref name="statusCode"/> is
                allowed to have a body.</returns>
        </member>
        <member name="T:RT.Servers.Cookie">
            <summary>
            Encapsulates an HTTP cookie.
            </summary>
        </member>
        <member name="T:RT.Servers.HttpCacheControl">
            <summary>
            Encapsulates the possible values of the Cache-Control HTTP request or response header.
            </summary>
        </member>
        <member name="F:RT.Servers.HttpCacheControl.State">
            <summary>Contains possible values of the Cache-Control header.</summary>
        </member>
        <member name="F:RT.Servers.HttpCacheControl.IntParameter">
            <summary>Some values of the Cache-Control header have an integer parameter.</summary>
        </member>
        <member name="F:RT.Servers.HttpCacheControl.StringParameter">
            <summary>Some values of the Cache-Control header have a string parameter.</summary>
        </member>
        <member name="M:RT.Servers.HttpCacheControl.ToString">
            <summary>Converts this structure to a valid element for the Cache-Control HTTP header. Throws if a required Int/String Parameter is missing.</summary>
        </member>
        <member name="P:RT.Servers.HttpCacheControl.NoCache">
            <summary>Provides a ready-made cache control collection that disables the caching completely.</summary>
        </member>
        <member name="T:RT.Servers.HttpContentDisposition">
            <summary>
            Encapsulates the possible values of the Content-Disposition HTTP response header.
            </summary>
        </member>
        <member name="F:RT.Servers.HttpContentDisposition.Mode">
            <summary>Currently supports only one value (“Attachment”).</summary>
        </member>
        <member name="F:RT.Servers.HttpContentDisposition.Filename">
            <summary>If Mode is “Attachment”, contains the filename of the attachment.</summary>
        </member>
        <member name="M:RT.Servers.HttpContentDisposition.Attachment(System.String)">
            <summary>Returns a value representing Content-Disposition: attachment, using the specified filename.</summary>
            <param name="filename">If null, the "filename" part is omitted from the header.</param>
        </member>
        <member name="T:RT.Servers.HttpContentRange">
            <summary>
            Encapsulates the possible values of the Content-Range HTTP response header.
            </summary>
        </member>
        <member name="F:RT.Servers.HttpContentRange.From">
            <summary>First byte index of the range. The first byte in the file has index 0.</summary>
        </member>
        <member name="F:RT.Servers.HttpContentRange.To">
            <summary>Last byte index of the range. For example, a range from 0 to 0 includes one byte.</summary>
        </member>
        <member name="F:RT.Servers.HttpContentRange.Total">
            <summary>Total size of the file (not of the range).</summary>
        </member>
        <member name="T:RT.Servers.HttpRange">
            <summary>
            Encapsulates one of the ranges specified in a Range HTTP request header.
            </summary>
        </member>
        <member name="F:RT.Servers.HttpRange.From">
            <summary>First byte index of the range. The first byte in the file has index 0.</summary>
        </member>
        <member name="F:RT.Servers.HttpRange.To">
            <summary>Last byte index of the range. For example, a range from 0 to 0 includes one byte.</summary>
        </member>
        <member name="T:RT.Servers.FileUpload">
            <summary>
            Represents a file upload contained in an HTTP POST request.
            </summary>
        </member>
        <member name="F:RT.Servers.FileUpload.LocalFilename">
            <summary>Use this if the file upload content is stored on disk.</summary>
        </member>
        <member name="F:RT.Servers.FileUpload.LocalFileMoved">
            <summary>Specifies that the handler has moved the local file to a destination place. (Prevents the file from being deleted during clean-up.)</summary>
        </member>
        <member name="F:RT.Servers.FileUpload.Data">
            <summary>Use this if the file upload content is stored in memory.</summary>
        </member>
        <member name="M:RT.Servers.FileUpload.#ctor(System.String,System.String)">
            <summary>Constructor.</summary>
        </member>
        <member name="M:RT.Servers.FileUpload.SaveToFile(System.String)">
            <summary>Moves the uploaded file to a file in the local file system.</summary>
            <remarks>Calling this method twice will move the file around, not create two copies.</remarks>
        </member>
        <member name="M:RT.Servers.FileUpload.GetStream">
            <summary>Returns a Stream object for access to the file upload.</summary>
            <remarks>The caller is responsible for disposing of the Stream object.</remarks>
        </member>
        <member name="M:RT.Servers.FileUpload.GetMd5">
            <summary>Returns the MD5 hash function of the upload contents.</summary>
            <returns>Result of the MD5 hash function as a string of hexadecimal digits.</returns>
        </member>
        <member name="P:RT.Servers.FileUpload.ContentType">
            <summary>The MIME type of the uploaded file.</summary>
        </member>
        <member name="P:RT.Servers.FileUpload.Filename">
            <summary>The filename of the uploaded file as supplied by the client.</summary>
        </member>
        <member name="T:RT.Servers.IHttpUrl">
            <summary>Supports base functionality of an HTTP URL.</summary>
        </member>
        <member name="M:RT.Servers.IHttpUrl.QueryValues(System.String)">
            <summary>
                Enumerates the values of the query-string parameters with the specified name (key). Implementors must return
                an empty sequence (rather than null) if no parameter has the specified name.</summary>
            <param name="name">
                The name (key) by which query parameters are identified.</param>
            <returns>
                A collection containing the values of the matching query-string parameters.</returns>
        </member>
        <member name="M:RT.Servers.IHttpUrl.AppendQueryString(System.Text.StringBuilder,System.Boolean)">
            <summary>
                Adds the query string to the specified <c>StringBuilder</c> instance.</summary>
            <param name="sb">
                An instance of <c>StringBuilder</c> to which the query string is added.</param>
            <param name="first">
                True to begin with a question mark (<c>?</c>), false to begin with an ampersand (<c>&amp;</c>).</param>
        </member>
        <member name="P:RT.Servers.IHttpUrl.Https">
            <summary>Specifies whether the protocol used is HTTPS (secure) or not.</summary>
        </member>
        <member name="P:RT.Servers.IHttpUrl.Port">
            <summary>
                Specifies the port.</summary>
            <remarks>
                The default for HTTP is 80. The default for HTTPS is 443.</remarks>
        </member>
        <member name="P:RT.Servers.IHttpUrl.ParentDomains">
            <summary>
                Specifies parts of the domain which were resolved via a compatible URL resolver. Must not be modified
                directly. Do not use this member directly; instead use a relevant extension method to manipulate the URL (such
                as <see cref="M:RT.Servers.IHttpUrlExtensions.WithDomainParent(RT.Servers.IHttpUrl)"/>).</summary>
        </member>
        <member name="P:RT.Servers.IHttpUrl.Domain">
            <summary>
                Specifies the domain part of the URL – that is, the part that comes before the first slash (or, if a URL
                resolver is used, the part that comes before the hook domain). The protocol is not included. Whenever not
                empty, Domain always ends with a dot unless it contains the full domain up to the TLD. Manipulate this part
                using <see cref="M:RT.Servers.IHttpUrlExtensions.WithDomain(RT.Servers.IHttpUrl,System.String)"/>.</summary>
        </member>
        <member name="P:RT.Servers.IHttpUrl.ParentPaths">
            <summary>
                Specifies parts of the URL path which were resolved via a compatible URL resolver. Must not be modified
                directly. Do not use this member directly; instead use a relevant extension method to manipulate the URL (such
                as <see cref="M:RT.Servers.IHttpUrlExtensions.WithPathParent(RT.Servers.IHttpUrl)"/>).</summary>
        </member>
        <member name="P:RT.Servers.IHttpUrl.Path">
            <summary>
                Specifies the path part of the URL – that is, the part that comes after the domain (or, if a URL resolver is
                used, the part that comes after the hook path). The query string is not included. Whenever not empty, Path
                always begins with a forward slash. Manipulate this part using <see cref="M:RT.Servers.IHttpUrlExtensions.WithPath(RT.Servers.IHttpUrl,System.String)"/> or
                <see cref="M:RT.Servers.IHttpUrlExtensions.WithPathOnly(RT.Servers.IHttpUrl,System.String)"/>.</summary>
        </member>
        <member name="P:RT.Servers.IHttpUrl.HasQuery">
            <summary>
                Specifies whether the path is followed by a query string (the part that begins with a <c>?</c> character).</summary>
        </member>
        <member name="P:RT.Servers.IHttpUrl.Query">
            <summary>
                Enumerates the query parameters as name/value pairs. Implementors must return an empty sequence if no query
                string is present, not null.</summary>
        </member>
        <member name="P:RT.Servers.IHttpUrl.QueryString">
            <summary>
                Gets the query string including the question mark character (<c>?</c>). Implementors must return an empty
                string if no query string is present, not null.</summary>
        </member>
        <member name="P:RT.Servers.IHttpUrl.Item(System.String)">
            <summary>
                Gets the first query-string value with the specified name, or null if no query parameter uses the specified
                name.</summary>
            <param name="name">
                The name (key) by which a query parameter is identified.</param>
            <returns>
                The value of the first matching query parameter or null.</returns>
        </member>
        <member name="T:RT.Servers.HttpUrl">
            <summary>Encapsulates information about a URL that identifies a resource on an HTTP server.</summary>
        </member>
        <member name="M:RT.Servers.HttpUrl.#ctor">
            <summary>Constructor.</summary>
        </member>
        <member name="M:RT.Servers.HttpUrl.#ctor(System.String,System.String)">
            <summary>
                Constructor.</summary>
            <param name="httpHost">
                The value of the HTTP "Host" header.</param>
            <param name="httpLocation">
                The value of the HTTP resource location field.</param>
        </member>
        <member name="M:RT.Servers.HttpUrl.#ctor(System.Boolean,System.String,System.String)">
            <summary>
                Constructor.</summary>
            <param name="https">
                Whether this is an HTTPS URL.</param>
            <param name="httpHost">
                The value of the HTTP "Host" header.</param>
            <param name="httpLocation">
                The value of the HTTP resource location field.</param>
        </member>
        <member name="M:RT.Servers.HttpUrl.#ctor(RT.Servers.IHttpUrl)">
            <summary>
                Creates a new instance based on the specified other URL.</summary>
            <param name="source">
                URL to copy information from.</param>
        </member>
        <member name="M:RT.Servers.HttpUrl.QueryValues(System.String)">
            <summary>Implements <see cref="M:RT.Servers.IHttpUrl.QueryValues(System.String)"/>.</summary>
        </member>
        <member name="M:RT.Servers.HttpUrl.AppendQueryString(System.Text.StringBuilder,System.Boolean)">
            <summary>Implements <see cref="M:RT.Servers.IHttpUrl.AppendQueryString(System.Text.StringBuilder,System.Boolean)"/>.</summary>
        </member>
        <member name="M:RT.Servers.HttpUrl.SetLocation(System.String)">
            <summary>Sets the part of the URL after the host, consisting of the path and optionally the query parameters.</summary>
        </member>
        <member name="M:RT.Servers.HttpUrl.SetHost(System.String)">
            <summary>Sets the host part of the URL, consisting of the domain and optionally the port number.</summary>
        </member>
        <member name="M:RT.Servers.HttpUrl.ToString">
            <summary>Returns the full URL.</summary>
        </member>
        <member name="P:RT.Servers.HttpUrl.Https">
            <summary>Implements <see cref="P:RT.Servers.IHttpUrl.Https"/>.</summary>
        </member>
        <member name="P:RT.Servers.HttpUrl.Port">
            <summary>Implements <see cref="P:RT.Servers.IHttpUrl.Port"/>.</summary>
        </member>
        <member name="P:RT.Servers.HttpUrl.ParentDomains">
            <summary>Implements <see cref="P:RT.Servers.IHttpUrl.ParentDomains"/>.</summary>
        </member>
        <member name="P:RT.Servers.HttpUrl.Domain">
            <summary>Implements <see cref="P:RT.Servers.IHttpUrl.Domain"/>.</summary>
        </member>
        <member name="P:RT.Servers.HttpUrl.ParentPaths">
            <summary>Implements <see cref="P:RT.Servers.IHttpUrl.ParentPaths"/>.</summary>
        </member>
        <member name="P:RT.Servers.HttpUrl.Path">
            <summary>Implements <see cref="P:RT.Servers.IHttpUrl.Path"/>.</summary>
        </member>
        <member name="P:RT.Servers.HttpUrl.Item(System.String)">
            <summary>Implements <see cref="P:RT.Servers.IHttpUrl.Item(System.String)"/>.</summary>
        </member>
        <member name="P:RT.Servers.HttpUrl.HasQuery">
            <summary>Implements <see cref="P:RT.Servers.IHttpUrl.HasQuery"/>.</summary>
        </member>
        <member name="P:RT.Servers.HttpUrl.Query">
            <summary>Implements <see cref="P:RT.Servers.IHttpUrl.Query"/>.</summary>
        </member>
        <member name="P:RT.Servers.HttpUrl.QueryString">
            <summary>Implements <see cref="P:RT.Servers.IHttpUrl.QueryString"/>.</summary>
        </member>
        <member name="T:RT.Servers.IHttpUrlExtensions">
            <summary>Provides extension functionality on the <see cref="T:RT.Servers.IHttpUrl"/> type.</summary>
        </member>
        <member name="M:RT.Servers.IHttpUrlExtensions.ToUrl(RT.Servers.IHttpUrl)">
            <summary>Creates an <see cref="T:RT.Servers.HttpUrl"/> instance containing a copy of the specified URL.</summary>
        </member>
        <member name="M:RT.Servers.IHttpUrlExtensions.ToHref(RT.Servers.IHttpUrl)">
            <summary>
                Returns the full path and query string of the specified URL (the part that follows the domain).</summary>
            <remarks>
                This is intended to be used as <c>href</c> attribute values in <c>&lt;a&gt;</c> tags as it works well for an
                absolute path within the same domain.</remarks>
        </member>
        <member name="M:RT.Servers.IHttpUrlExtensions.ToFull(RT.Servers.IHttpUrl)">
            <summary>Returns the full and complete URL as a single string.</summary>
        </member>
        <member name="M:RT.Servers.IHttpUrlExtensions.GetFullPath(RT.Servers.IHttpUrl)">
            <summary>
                Returns the full path (the part that comes after the domain) regardless of any URL resolvers in use. The query
                string is not included.</summary>
        </member>
        <member name="M:RT.Servers.IHttpUrlExtensions.GetFullDomain(RT.Servers.IHttpUrl)">
            <summary>
                Returns the full domain name (the part that comes before the first slash) regardless of any URL resolvers in
                use. The protocol and the port number is not included.</summary>
        </member>
        <member name="M:RT.Servers.IHttpUrlExtensions.WithHttps(RT.Servers.IHttpUrl,System.Boolean)">
            <summary>
                Returns a new URL consisting of the specified URL but with the protocol changed.</summary>
            <param name="url">
                Source URL.</param>
            <param name="https">
                True to change the protocol to https; otherwise http.</param>
        </member>
        <member name="M:RT.Servers.IHttpUrlExtensions.WithDomain(RT.Servers.IHttpUrl,System.String)">
            <summary>
                Returns a new URL with the <see cref="P:RT.Servers.IHttpUrl.Domain"/> changed. The domain must be empty or end with a dot,
                unless it is at the TLD level, in which case it must be non-empty and not end with a dot.</summary>
        </member>
        <member name="M:RT.Servers.IHttpUrlExtensions.WithDomainParent(RT.Servers.IHttpUrl)">
            <summary>
                Returns a new URL such that the <see cref="P:RT.Servers.IHttpUrl.Domain"/> includes the part matched by the most recent URL
                resolver.</summary>
        </member>
        <member name="M:RT.Servers.IHttpUrlExtensions.WithPath(RT.Servers.IHttpUrl,System.String)">
            <summary>
                Returns a new URL with the <see cref="P:RT.Servers.IHttpUrl.Path"/> changed. The path must be empty or begin with a forward
                slash, and must not contain a query string.</summary>
        </member>
        <member name="M:RT.Servers.IHttpUrlExtensions.WithPathOnly(RT.Servers.IHttpUrl,System.String)">
            <summary>
                Returns a new URL with the <see cref="P:RT.Servers.IHttpUrl.Path"/> changed and the query string removed. The path must be
                empty or begin with a forward slash, and must not contain a query string.</summary>
        </member>
        <member name="M:RT.Servers.IHttpUrlExtensions.WithPathParent(RT.Servers.IHttpUrl)">
            <summary>
                Returns a new URL such that the <see cref="P:RT.Servers.IHttpUrl.Path"/> includes the part matched by the most recent URL
                resolver.</summary>
        </member>
        <member name="M:RT.Servers.IHttpUrlExtensions.WithoutQuery(RT.Servers.IHttpUrl)">
            <summary>Returns a new URL consisting of the specified URL without the query string.</summary>
        </member>
        <member name="M:RT.Servers.IHttpUrlExtensions.WithoutQuery(RT.Servers.IHttpUrl,System.String)">
            <summary>Returns a new URL consisting of the specified URL with the specified query parameter removed.</summary>
        </member>
        <member name="M:RT.Servers.IHttpUrlExtensions.WithoutQuery(RT.Servers.IHttpUrl,System.String[])">
            <summary>Returns a new URL consisting of the specified URL with the specified query parameters removed.</summary>
        </member>
        <member name="M:RT.Servers.IHttpUrlExtensions.WithoutQuery(RT.Servers.IHttpUrl,System.Collections.Generic.IEnumerable{System.String})">
            <summary>Returns a new URL consisting of the specified URL with the specified query parameters removed.</summary>
        </member>
        <member name="M:RT.Servers.IHttpUrlExtensions.WithoutQuery(RT.Servers.IHttpUrl,System.Collections.Generic.HashSet{System.String})">
            <summary>Returns a new URL consisting of the specified URL with the specified query parameters removed.</summary>
        </member>
        <member name="M:RT.Servers.IHttpUrlExtensions.WithQuery(RT.Servers.IHttpUrl,System.String,System.String)">
            <summary>
                Returns a new URL consisting of the specified URL with the specified query parameter replaced with the
                specified value.</summary>
        </member>
        <member name="M:RT.Servers.IHttpUrlExtensions.WithQuery(RT.Servers.IHttpUrl,System.String,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
                Returns a new URL consisting of the specified URL with the specified query parameter replaced with the
                specified set of values.</summary>
        </member>
        <member name="M:RT.Servers.IHttpUrlExtensions.WithQuery(RT.Servers.IHttpUrl,System.String,System.String[])">
            <summary>
                Returns a new URL consisting of the specified URL with the specified query parameter replaced with the
                specified set of values.</summary>
        </member>
        <member name="M:RT.Servers.IHttpUrlExtensions.Where(RT.Servers.IHttpUrl,System.Func{System.String,System.Boolean})">
            <summary>
                Returns a new URL consisting of the specified URL but containing only those query parameters whose name
                matches the specified predicate.</summary>
        </member>
        <member name="M:RT.Servers.IHttpUrlExtensions.Where(RT.Servers.IHttpUrl,System.Func{System.String,System.String,System.Boolean})">
            <summary>
                Returns a new URL consisting of the specified URL but containing only those query parameters whose name/value
                pair matches the specified predicate.</summary>
        </member>
        <member name="M:RT.Servers.IHttpUrlExtensions.With(RT.Servers.IHttpUrl,System.String,System.Boolean,System.Boolean)">
            <summary>
                Changes a URL’s subpath or subdomain.</summary>
            <param name="url">
                The URL to modify.</param>
            <param name="pathOrSubdomain">
                The new subpath or subdomain, without any slashes or dots.</param>
            <param name="useSubdomain">
                If <c>true</c>, the subdomain is changed; if <c>false</c> (default), the path is changed.</param>
            <param name="retainQueryParams">
                If <c>true</c>, the query parameters are retained; if <c>false</c> (default), they are removed.</param>
            <returns>
                The new URL.</returns>
        </member>
        <member name="M:RT.Servers.IHttpUrlExtensions.WithParent(RT.Servers.IHttpUrl,System.String,System.Boolean,System.Boolean)">
            <summary>
                Changes a URL’s subpath or subdomain relative to the most recent URL resolver.</summary>
            <param name="url">
                The URL to modify.</param>
            <param name="pathOrSubdomain">
                The new subpath or subdomain, without any slashes or dots.</param>
            <param name="useSubdomain">
                If <c>true</c>, the subdomain is changed; if <c>false</c> (default), the path is changed.</param>
            <param name="retainQueryParams">
                If <c>true</c>, the query parameters are retained; if <c>false</c> (default), they are removed.</param>
            <returns>
                The new URL.</returns>
        </member>
        <member name="M:RT.Servers.IHttpUrlExtensions.WithParents(RT.Servers.IHttpUrl,System.Int32,System.String,System.Boolean,System.Boolean)">
            <summary>
                Changes a URL’s subpath or subdomain relative to the specified number of URL resolvers.</summary>
            <param name="url">
                The URL to modify.</param>
            <param name="levels">
                The number of URL resolvers to rewind.</param>
            <param name="pathOrSubdomain">
                The new subpath or subdomain, without any slashes or dots.</param>
            <param name="useSubdomain">
                If <c>true</c>, the subdomain is changed; if <c>false</c> (default), the path is changed.</param>
            <param name="retainQueryParams">
                If <c>true</c>, the query parameters are retained; if <c>false</c> (default), they are removed.</param>
            <returns>
                The new URL.</returns>
        </member>
        <member name="T:RT.Servers.HttpHelper">
            <summary>Contains helper methods to deal with various things in HTTP.</summary>
        </member>
        <member name="M:RT.Servers.HttpHelper.ParseQueryString(System.String)">
            <summary>
                Parses the specified string as a URL query string. The string is expected to be either empty or start with a <c>'?'</c>.</summary>
            <param name="input">
                The string to parse.</param>
            <returns>
                A list containing the key/value pairs extracted from the string.</returns>
        </member>
        <member name="M:RT.Servers.HttpHelper.ParseQueryValueParameters(System.IO.TextReader)">
            <summary>
                Decodes a URL-encoded stream of UTF-8 characters into key-value pairs.</summary>
            <param name="s">
                Stream to read from.</param>
        </member>
        <member name="T:RT.Servers.NameValuesCollection`1">
            <summary>
            Encapsulates a collection that maps keys to collections of values.
            Provides the ability to cheaply make the collection fully read-only.
            Provides a sort of auto-vivification for convenience.
            </summary>
            <example>
            <code>
                // initially myNameValue does not contain the key "fruits"
                int c = myNameValues["fruits"].Count;  // c == 0
                myNameValues["fruits"].Add("orange");
                // myNameValue now contains the key "fruits", with one value associated.
            </code>
            </example>
            <typeparam name="TValue">The type of the values to be associated with each key.</typeparam>
        </member>
        <member name="M:RT.Servers.NameValuesCollection`1.#ctor">
            <summary>
            Creates an empty collection.
            </summary>
        </member>
        <member name="M:RT.Servers.NameValuesCollection`1.#ctor(System.Int32)">
            <summary>
            Creates an empty collection.
            </summary>
            <param name="capacity">Initial capacity, in terms of keys.</param>
        </member>
        <member name="M:RT.Servers.NameValuesCollection`1.AsReadOnly">
            <summary>
            Returns a read-only version of this collection. The returned collection could be the
            same as this one, if it's already read-only, or it could be a wrapper created around
            the items in this collection. If the original collection gets modified, the read-only
            version will reflect the changes instantly.
            </summary>
        </member>
        <member name="M:RT.Servers.NameValuesCollection`1.Add(System.String,RT.Servers.ValuesCollection{`0})">
            <summary>
            Adds all items from the specified value collection, associating them with
            the specified key. Throws an exception if the specified key already has items
            associated with it.
            </summary>
            <param name="key">Key to associate the items with.</param>
            <param name="value">Collection containing the values to add.</param>
        </member>
        <member name="M:RT.Servers.NameValuesCollection`1.ContainsKey(System.String)">
            <summary>
            Returns true iff this collection has at least one value associated with the specified key.
            </summary>
        </member>
        <member name="M:RT.Servers.NameValuesCollection`1.Remove(System.String)">
            <summary>
            Removes all items associated with the specified key. Returns true iff any items were removed.
            </summary>
        </member>
        <member name="M:RT.Servers.NameValuesCollection`1.TryGetValue(System.String,RT.Servers.ValuesCollection{`0}@)">
            <summary>
            Gets the collection of values associated with the specified key, or an empty collection
            if no such items exist. Returns true iff any items are associated with the key.
            </summary>
        </member>
        <member name="M:RT.Servers.NameValuesCollection`1.Add(System.Collections.Generic.KeyValuePair{System.String,RT.Servers.ValuesCollection{`0}})">
            <summary>
            Adds the specified key and value collection.
            </summary>
        </member>
        <member name="M:RT.Servers.NameValuesCollection`1.Clear">
            <summary>
            Clears all items from this collection.
            </summary>
        </member>
        <member name="M:RT.Servers.NameValuesCollection`1.Contains(System.Collections.Generic.KeyValuePair{System.String,RT.Servers.ValuesCollection{`0}})">
            <summary>
            Not implemented.
            </summary>
        </member>
        <member name="M:RT.Servers.NameValuesCollection`1.CopyTo(System.Collections.Generic.KeyValuePair{System.String,RT.Servers.ValuesCollection{`0}}[],System.Int32)">
            <summary>
            Copies all key/value-collection pairs to the specified array.
            </summary>
        </member>
        <member name="M:RT.Servers.NameValuesCollection`1.Remove(System.Collections.Generic.KeyValuePair{System.String,RT.Servers.ValuesCollection{`0}})">
            <summary>
            Not implemented.
            </summary>
        </member>
        <member name="M:RT.Servers.NameValuesCollection`1.GetEnumerator">
            <summary>
            Gets an enumerator to iterate over all key/value-collection pairs in this collection.
            </summary>
        </member>
        <member name="M:RT.Servers.NameValuesCollection`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Gets an enumerator to iterate over all key/value-collection pairs in this collection.
            </summary>
        </member>
        <member name="P:RT.Servers.NameValuesCollection`1.Keys">
            <summary>
            Gets a collection of the keys that have at least one value associated with them. This
            method is not particularly cheap.
            </summary>
        </member>
        <member name="P:RT.Servers.NameValuesCollection`1.Values">
            <summary>
            Gets the collection of all value collections. This method is not particularly cheap.
            </summary>
        </member>
        <member name="P:RT.Servers.NameValuesCollection`1.Item(System.String)">
            <summary>
            Gets or sets a collection of values associated with the specified key.
            </summary>
        </member>
        <member name="P:RT.Servers.NameValuesCollection`1.Count">
            <summary>
            Gets the number of keys in this collection which have at least one value associated with them.
            </summary>
        </member>
        <member name="P:RT.Servers.NameValuesCollection`1.IsReadOnly">
            <summary>
            Returns true iff this collection is read-only (cannot be modified).
            </summary>
        </member>
        <member name="T:RT.Servers.ValuesCollection`1">
            <summary>
            Represents a collection of values associated with a single key inside a <see cref="T:RT.Servers.NameValuesCollection`1"/>.
            </summary>
            <remarks>
            Implemented as a wrapper for a List which can be read-only or read-write as desired.
            </remarks>
            <typeparam name="TValue">The type of the values stored in this collection.</typeparam>
        </member>
        <member name="F:RT.Servers.ValuesCollection`1._values">
            <summary>The collection being wrapped. Both null and an empty list may stand for empty.</summary>
        </member>
        <member name="F:RT.Servers.ValuesCollection`1._isWritable">
            <summary>
            If false, the wrapped collection cannot be modified through this struct (read-only).
            The reason this isn’t “isReadOnly” is that <c>default(ValuesCollection&lt;TValue&gt;)</c>
            and <c>new ValuesCollection&lt;TValue&gt;()</c> would otherwise generate an invalid
            collection: <see name="_values"/> would be null, so no values could be added.
            </summary>
        </member>
        <member name="M:RT.Servers.ValuesCollection`1.#ctor(System.Collections.Generic.List{`0},System.Boolean)">
            <summary>
            Creates a wrapper for the specified list instance. The list may be null to represent an empty
            wrapper provided that the wrapper is read-only.
            </summary>
            <param name="values">The list to wrap. May be null for an empty read-only wrapper.</param>
            <param name="isReadOnly">Specifies whether the wrapper allows the wrapped list to be modified.</param>
            <remarks>This constructor does NOT create a copy of the list. Thus, even if <paramref name="isReadOnly"/> is true,
            the list may still be modified if a reference to the list is accessed elsewhere. Consider only passing in lists which you
            created and are not passed or used anywhere else.</remarks>
        </member>
        <member name="M:RT.Servers.ValuesCollection`1.CreateEmpty">
            <summary>Creates a writable (non-read-only) empty <see cref="T:RT.Servers.ValuesCollection`1"/>.</summary>
        </member>
        <member name="M:RT.Servers.ValuesCollection`1.Create(`0[])">
            <summary>Creates a writable (non-read-only) <see cref="T:RT.Servers.ValuesCollection`1"/> containing the specified values.</summary>
        </member>
        <member name="M:RT.Servers.ValuesCollection`1.CreateReadOnly(`0[])">
            <summary>Creates a read-only <see cref="T:RT.Servers.ValuesCollection`1"/> containing the specified values.</summary>
        </member>
        <member name="M:RT.Servers.ValuesCollection`1.op_Implicit(`0[])~RT.Servers.ValuesCollection{`0}">
            <summary>Creates a read-only <see cref="T:RT.Servers.ValuesCollection`1"/> containing the specified values.</summary>
        </member>
        <member name="M:RT.Servers.ValuesCollection`1.op_Implicit(System.Collections.Generic.List{`0})~RT.Servers.ValuesCollection{`0}">
            <summary>Creates a read-only <see cref="T:RT.Servers.ValuesCollection`1"/> wrapping the specified list instance.</summary>
            <remarks>This operator does NOT create a copy of the list. The list may still be modified if a reference to the list is accessed
            elsewhere. Consider only passing in lists which you created and are not passed or used anywhere else.</remarks>
        </member>
        <member name="M:RT.Servers.ValuesCollection`1.IndexOf(`0)">
            <summary>
            Returns the index of the specified item in this collection, or -1 if not found.
            </summary>
            <param name="item">Item to be searched for.</param>
        </member>
        <member name="M:RT.Servers.ValuesCollection`1.Insert(System.Int32,`0)">
            <summary>
            Inserts the item at the specified position.
            </summary>
        </member>
        <member name="M:RT.Servers.ValuesCollection`1.RemoveAt(System.Int32)">
            <summary>
            Removes the item at the specified position from the collection.
            </summary>
        </member>
        <member name="M:RT.Servers.ValuesCollection`1.Add(`0)">
            <summary>
            Adds the specified value to the collection.
            </summary>
        </member>
        <member name="M:RT.Servers.ValuesCollection`1.Clear">
            <summary>
            Clears all items from the collection.
            </summary>
        </member>
        <member name="M:RT.Servers.ValuesCollection`1.Contains(`0)">
            <summary>
            Returns true iff the collection contains the specified item.
            </summary>
        </member>
        <member name="M:RT.Servers.ValuesCollection`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copies all items in this collection to the specified array.
            </summary>
        </member>
        <member name="M:RT.Servers.ValuesCollection`1.Remove(`0)">
            <summary>
            Removes the specified item from the collection. Returns true iff an item was removed.
            </summary>
        </member>
        <member name="M:RT.Servers.ValuesCollection`1.GetEnumerator">
            <summary>
            Returns an enumerator to iterate over all items in this collection.
            </summary>
        </member>
        <member name="M:RT.Servers.ValuesCollection`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator to iterate over all items in this collection.
            </summary>
        </member>
        <member name="M:RT.Servers.ValuesCollection`1.ToString">
            <summary>
            Returns a string listing all values in the collection, comma-separated, inside square brackets.
            </summary>
        </member>
        <member name="P:RT.Servers.ValuesCollection`1.Item(System.Int32)">
            <summary>
            Gets or sets the value at the specified index.
            </summary>
        </member>
        <member name="P:RT.Servers.ValuesCollection`1.Value">
            <summary>
            Gets the first value stored in this value collection. If the collection is empty,
            returns the default value for <typeparamref name="TValue"/> (i.e. null for all reference types).
            </summary>
        </member>
        <member name="P:RT.Servers.ValuesCollection`1.Count">
            <summary>
            Gets the count of items stored in this collection.
            </summary>
        </member>
        <member name="P:RT.Servers.ValuesCollection`1.IsReadOnly">
            <summary>
            Returns true iff this collection is read-only (cannot be modified).
            </summary>
        </member>
        <member name="T:RT.Servers.NameValuesCollectionExtensions">
            <summary>Extension methods for <see cref="T:RT.Servers.NameValuesCollection`1"/>.</summary>
        </member>
        <member name="M:RT.Servers.NameValuesCollectionExtensions.ToNameValuesCollection``1(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,``0}})">
            <summary>Creates a <see cref="T:RT.Servers.NameValuesCollection`1"/> from a collection of key-value pairs.</summary>
        </member>
        <member name="T:RT.Servers.SharpZipLib.Checksums.Adler32">
            <summary>
            Computes Adler32 checksum for a stream of data. An Adler32
            checksum is not as reliable as a CRC32 checksum, but a lot faster to
            compute.
            
            The specification for Adler32 may be found in RFC 1950.
            ZLIB Compressed Data Format Specification version 3.3)
            
            
            From that document:
            
                 "ADLER32 (Adler-32 checksum)
                  This contains a checksum value of the uncompressed data
                  (excluding any dictionary data) computed according to Adler-32
                  algorithm. This algorithm is a 32-bit extension and improvement
                  of the Fletcher algorithm, used in the ITU-T X.224 / ISO 8073
                  standard.
            
                  Adler-32 is composed of two sums accumulated per byte: s1 is
                  the sum of all bytes, s2 is the sum of all s1 values. Both sums
                  are done modulo 65521. s1 is initialized to 1, s2 to zero.  The
                  Adler-32 checksum is stored as s2*65536 + s1 in most-
                  significant-byte first (network) order."
            
             "8.2. The Adler-32 algorithm
            
               The Adler-32 algorithm is much faster than the CRC32 algorithm yet
               still provides an extremely low probability of undetected errors.
            
               The modulo on unsigned long accumulators can be delayed for 5552
               bytes, so the modulo operation time is negligible.  If the bytes
               are a, b, c, the second sum is 3a + 2b + c + 3, and so is position
               and order sensitive, unlike the first sum, which is just a
               checksum.  That 65521 is prime is important to avoid a possible
               large class of two-byte errors that leave the check unchanged.
               (The Fletcher checksum uses 255, which is not prime and which also
               makes the Fletcher check insensitive to single byte changes 0 -
               255.)
            
               The sum s1 is initialized to 1 instead of zero to make the length
               of the sequence part of s2, so that the length does not have to be
               checked separately. (Any sequence of zeroes has a Fletcher
               checksum of zero.)"
            </summary>
            <see cref="T:RT.Servers.SharpZipLib.Zip.Compression.Streams.InflaterInputStream"/>
            <see cref="T:RT.Servers.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream"/>
        </member>
        <member name="T:RT.Servers.SharpZipLib.Checksums.IChecksum">
            <summary>
            Interface to compute a data checksum used by checked input/output streams.
            A data checksum can be updated by one byte or with a byte array. After each
            update the value of the current checksum can be returned by calling
            <code>getValue</code>. The complete checksum object can also be reset
            so it can be used again with new data.
            </summary>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Checksums.IChecksum.Reset">
            <summary>
            Resets the data checksum as if no update was ever called.
            </summary>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Checksums.IChecksum.Update(System.Int32)">
            <summary>
            Adds one byte to the data checksum.
            </summary>
            <param name = "value">
            the data value to add. The high byte of the int is ignored.
            </param>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Checksums.IChecksum.Update(System.Byte[])">
            <summary>
            Updates the data checksum with the bytes taken from the array.
            </summary>
            <param name="buffer">
            buffer an array of bytes
            </param>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Checksums.IChecksum.Update(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Adds the byte array to the data checksum.
            </summary>
            <param name = "buffer">
            The buffer which contains the data
            </param>
            <param name = "offset">
            The offset in the buffer where the data starts
            </param>
            <param name = "count">
            the number of data bytes to add.
            </param>
        </member>
        <member name="P:RT.Servers.SharpZipLib.Checksums.IChecksum.Value">
            <summary>
            Returns the data checksum computed so far.
            </summary>
        </member>
        <member name="F:RT.Servers.SharpZipLib.Checksums.Adler32.BASE">
            <summary>
            largest prime smaller than 65536
            </summary>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Checksums.Adler32.#ctor">
            <summary>
            Creates a new instance of the Adler32 class.
            The checksum starts off with a value of 1.
            </summary>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Checksums.Adler32.Reset">
            <summary>
            Resets the Adler32 checksum to the initial value.
            </summary>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Checksums.Adler32.Update(System.Int32)">
            <summary>
            Updates the checksum with a byte value.
            </summary>
            <param name="value">
            The data value to add. The high byte of the int is ignored.
            </param>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Checksums.Adler32.Update(System.Byte[])">
            <summary>
            Updates the checksum with an array of bytes.
            </summary>
            <param name="buffer">
            The source of the data to update with.
            </param>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Checksums.Adler32.Update(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Updates the checksum with the bytes taken from the array.
            </summary>
            <param name="buffer">
            an array of bytes
            </param>
            <param name="offset">
            the start of the data used for this update
            </param>
            <param name="count">
            the number of bytes to use for this update
            </param>
        </member>
        <member name="P:RT.Servers.SharpZipLib.Checksums.Adler32.Value">
            <summary>
            Returns the Adler32 data checksum computed so far.
            </summary>
        </member>
        <member name="T:RT.Servers.SharpZipLib.Checksums.Crc32">
             <summary>
             Generate a table for a byte-wise 32-bit CRC calculation on the polynomial:
             x^32+x^26+x^23+x^22+x^16+x^12+x^11+x^10+x^8+x^7+x^5+x^4+x^2+x+1.
            
             Polynomials over GF(2) are represented in binary, one bit per coefficient,
             with the lowest powers in the most significant bit.  Then adding polynomials
             is just exclusive-or, and multiplying a polynomial by x is a right shift by
             one.  If we call the above polynomial p, and represent a byte as the
             polynomial q, also with the lowest power in the most significant bit (so the
             byte 0xb1 is the polynomial x^7+x^3+x+1), then the CRC is (q*x^32) mod p,
             where a mod b means the remainder after dividing a by b.
            
             This calculation is done using the shift-register method of multiplying and
             taking the remainder.  The register is initialized to zero, and for each
             incoming bit, x^32 is added mod p to the register if the bit is a one (where
             x^32 mod p is p+x^32 = x^26+...+1), and the register is multiplied mod p by
             x (which is shifting right by one and adding x^32 mod p if the bit shifted
             out is a one).  We start with the highest power (least significant bit) of
             q and repeat for all eight bits of q.
            
             The table is simply the CRC of all possible eight bit values.  This is all
             the information needed to generate CRC's on data a byte at a time for all
             combinations of CRC register values and incoming bytes.
             </summary>
        </member>
        <member name="F:RT.Servers.SharpZipLib.Checksums.Crc32.crc">
            <summary>
            The crc data checksum so far.
            </summary>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Checksums.Crc32.Reset">
            <summary>
            Resets the CRC32 data checksum as if no update was ever called.
            </summary>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Checksums.Crc32.Update(System.Int32)">
            <summary>
            Updates the checksum with the int bval.
            </summary>
            <param name = "value">
            the byte is taken as the lower 8 bits of value
            </param>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Checksums.Crc32.Update(System.Byte[])">
            <summary>
            Updates the checksum with the bytes taken from the array.
            </summary>
            <param name="buffer">
            buffer an array of bytes
            </param>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Checksums.Crc32.Update(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Adds the byte array to the data checksum.
            </summary>
            <param name = "buffer">
            The buffer which contains the data
            </param>
            <param name = "offset">
            The offset in the buffer where the data starts
            </param>
            <param name = "count">
            The number of data bytes to update the CRC with.
            </param>
        </member>
        <member name="P:RT.Servers.SharpZipLib.Checksums.Crc32.Value">
            <summary>
            Returns the CRC32 data checksum computed so far.
            </summary>
        </member>
        <member name="T:RT.Servers.SharpZipLib.GZip.GZipConstants">
            <summary>
            This class contains constants used for gzip.
            </summary>
        </member>
        <member name="F:RT.Servers.SharpZipLib.GZip.GZipConstants.GZIP_MAGIC">
            <summary>
            Magic number found at start of GZIP header
            </summary>
        </member>
        <member name="F:RT.Servers.SharpZipLib.GZip.GZipConstants.FTEXT">
            <summary>
            Flag bit mask for text
            </summary>
        </member>
        <member name="F:RT.Servers.SharpZipLib.GZip.GZipConstants.FHCRC">
            <summary>
            Flag bitmask for Crc
            </summary>
        </member>
        <member name="F:RT.Servers.SharpZipLib.GZip.GZipConstants.FEXTRA">
            <summary>
            Flag bit mask for extra
            </summary>
        </member>
        <member name="F:RT.Servers.SharpZipLib.GZip.GZipConstants.FNAME">
            <summary>
            flag bitmask for name
            </summary>
        </member>
        <member name="F:RT.Servers.SharpZipLib.GZip.GZipConstants.FCOMMENT">
            <summary>
            flag bit mask indicating comment is present
            </summary>
        </member>
        <member name="M:RT.Servers.SharpZipLib.GZip.GZipConstants.#ctor">
            <summary>
            Initialise default instance.
            </summary>
            <remarks>Constructor is private to prevent instances being created.</remarks>
        </member>
        <member name="T:RT.Servers.SharpZipLib.GZip.GZipException">
            <summary>
            GZipException represents a Gzip specific exception	
            </summary>
        </member>
        <member name="T:RT.Servers.SharpZipLib.SharpZipBaseException">
            <summary>
            SharpZipBaseException is the base exception class for the SharpZipLibrary.
            All library exceptions are derived from this.
            </summary>
            <remarks>NOTE: Not all exceptions thrown will be derived from this class.
            A variety of other exceptions are possible for example <see cref="T:System.ArgumentNullException"></see></remarks>
        </member>
        <member name="M:RT.Servers.SharpZipLib.SharpZipBaseException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Deserialization constructor 
            </summary>
            <param name="info"><see cref="T:System.Runtime.Serialization.SerializationInfo"/> for this constructor</param>
            <param name="context"><see cref="T:System.Runtime.Serialization.StreamingContext"/> for this constructor</param>
        </member>
        <member name="M:RT.Servers.SharpZipLib.SharpZipBaseException.#ctor">
            <summary>
            Initializes a new instance of the SharpZipBaseException class.
            </summary>
        </member>
        <member name="M:RT.Servers.SharpZipLib.SharpZipBaseException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the SharpZipBaseException class with a specified error message.
            </summary>
            <param name="message">A message describing the exception.</param>
        </member>
        <member name="M:RT.Servers.SharpZipLib.SharpZipBaseException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the SharpZipBaseException class with a specified
            error message and a reference to the inner exception that is the cause of this exception.
            </summary>
            <param name="message">A message describing the exception.</param>
            <param name="innerException">The inner exception</param>
        </member>
        <member name="M:RT.Servers.SharpZipLib.GZip.GZipException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Deserialization constructor 
            </summary>
            <param name="info"><see cref="T:System.Runtime.Serialization.SerializationInfo"/> for this constructor</param>
            <param name="context"><see cref="T:System.Runtime.Serialization.StreamingContext"/> for this constructor</param>
        </member>
        <member name="M:RT.Servers.SharpZipLib.GZip.GZipException.#ctor">
            <summary>
            Initialise a new instance of GZipException
            </summary>
        </member>
        <member name="M:RT.Servers.SharpZipLib.GZip.GZipException.#ctor(System.String)">
            <summary>
            Initialise a new instance of GZipException with its message string.
            </summary>
            <param name="message">A <see cref="T:System.String"/> that describes the error.</param>
        </member>
        <member name="M:RT.Servers.SharpZipLib.GZip.GZipException.#ctor(System.String,System.Exception)">
            <summary>
            Initialise a new instance of <see cref="T:RT.Servers.SharpZipLib.GZip.GZipException"></see>.
            </summary>
            <param name="message">A <see cref="T:System.String"/> that describes the error.</param>
            <param name="innerException">The <see cref="T:System.Exception"/> that caused this exception.</param>
        </member>
        <member name="T:RT.Servers.SharpZipLib.GZip.GZipInputStream">
            <summary>
            This filter stream is used to decompress a "GZIP" format stream.
            The "GZIP" format is described baseInputStream RFC 1952.
            
            author of the original java version : John Leuner
            </summary>
            <example> This sample shows how to unzip a gzipped file
            <code>
            using System;
            using System.IO;
            
            using RT.Servers.SharpZipLib.Core;
            using RT.Servers.SharpZipLib.GZip;
            
            class MainClass
            {
            	public static void Main(string[] args)
            	{
            		using (Stream inStream = new GZipInputStream(File.OpenRead(args[0])))
            		using (FileStream outStream = File.Create(Path.GetFileNameWithoutExtension(args[0]))) {
            			byte[] buffer = new byte[4096];
            			StreamUtils.Copy(inStream, outStream, buffer);
            		}
            	}
            }	
            </code>
            </example>
        </member>
        <member name="T:RT.Servers.SharpZipLib.Zip.Compression.Streams.InflaterInputStream">
             <summary>
             This filter stream is used to decompress data compressed using the "deflate"
             format. The "deflate" format is described in RFC 1951.
            
             This stream may form the basis for other decompression filters, such
             as the <see cref="T:RT.Servers.SharpZipLib.GZip.GZipInputStream">GZipInputStream</see>.
            
             Author of the original java version : John Leuner.
             </summary>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.#ctor(System.IO.Stream)">
            <summary>
            Create an InflaterInputStream with the default decompressor
            and a default buffer size of 4KB.
            </summary>
            <param name = "baseInputStream">
            The InputStream to read bytes from
            </param>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.#ctor(System.IO.Stream,RT.Servers.SharpZipLib.Zip.Compression.Inflater)">
            <summary>
            Create an InflaterInputStream with the specified decompressor
            and a default buffer size of 4KB.
            </summary>
            <param name = "baseInputStream">
            The source of input data
            </param>
            <param name = "inf">
            The decompressor used to decompress data read from baseInputStream
            </param>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.#ctor(System.IO.Stream,RT.Servers.SharpZipLib.Zip.Compression.Inflater,System.Int32)">
            <summary>
            Create an InflaterInputStream with the specified decompressor
            and the specified buffer size.
            </summary>
            <param name = "baseInputStream">
            The InputStream to read bytes from
            </param>
            <param name = "inflater">
            The decompressor to use
            </param>
            <param name = "bufferSize">
            Size of the buffer to use
            </param>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.Skip(System.Int64)">
            <summary>
            Skip specified number of bytes of uncompressed data
            </summary>
            <param name="count">
            Number of bytes to skip
            </param>
            <returns>
            The number of bytes skipped, zero if the end of 
            stream has been reached
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="count">The number of bytes</paramref> to skip is less than or equal to zero.
            </exception>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.StopDecrypting">
            <summary>
            Clear any cryptographic state.
            </summary>		
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.Fill">
            <summary>
            Fills the buffer with more data to decompress.
            </summary>
            <exception cref="T:RT.Servers.SharpZipLib.SharpZipBaseException">
            Stream ends early
            </exception>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.Flush">
            <summary>
            Flushes the baseInputStream
            </summary>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            Sets the position within the current stream
            Always throws a NotSupportedException
            </summary>
            <param name="offset">The relative offset to seek to.</param>
            <param name="origin">The <see cref="T:System.IO.SeekOrigin"/> defining where to seek from.</param>
            <returns>The new position in the stream.</returns>
            <exception cref="T:System.NotSupportedException">Any access</exception>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.SetLength(System.Int64)">
            <summary>
            Set the length of the current stream
            Always throws a NotSupportedException
            </summary>
            <param name="value">The new length value for the stream.</param>
            <exception cref="T:System.NotSupportedException">Any access</exception>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Writes a sequence of bytes to stream and advances the current position
            This method always throws a NotSupportedException
            </summary>
            <param name="buffer">Thew buffer containing data to write.</param>
            <param name="offset">The offset of the first byte to write.</param>
            <param name="count">The number of bytes to write.</param>
            <exception cref="T:System.NotSupportedException">Any access</exception>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.WriteByte(System.Byte)">
            <summary>
            Writes one byte to the current stream and advances the current position
            Always throws a NotSupportedException
            </summary>
            <param name="value">The byte to write.</param>
            <exception cref="T:System.NotSupportedException">Any access</exception>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
            <summary>
            Entry point to begin an asynchronous write.  Always throws a NotSupportedException.
            </summary>
            <param name="buffer">The buffer to write data from</param>
            <param name="offset">Offset of first byte to write</param>
            <param name="count">The maximum number of bytes to write</param>
            <param name="callback">The method to be called when the asynchronous write operation is completed</param>
            <param name="state">A user-provided object that distinguishes this particular asynchronous write request from other requests</param>
            <returns>An <see cref="T:System.IAsyncResult">IAsyncResult</see> that references the asynchronous write</returns>
            <exception cref="T:System.NotSupportedException">Any access</exception>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.Close">
            <summary>
            Closes the input stream.  When <see cref="P:RT.Servers.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.IsStreamOwner"></see>
            is true the underlying stream is also closed.
            </summary>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads decompressed data into the provided buffer byte array
            </summary>
            <param name="buffer">
            The array to read and decompress data into
            </param>
            <param name="offset">
            The offset indicating where the data should be placed
            </param>
            <param name="count">
            The number of bytes to decompress
            </param>
            <returns>The number of bytes read.  Zero signals the end of stream</returns>
            <exception cref="T:RT.Servers.SharpZipLib.SharpZipBaseException">
            Inflater needs a dictionary
            </exception>
        </member>
        <member name="F:RT.Servers.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.inf">
            <summary>
            Decompressor for this stream
            </summary>
        </member>
        <member name="F:RT.Servers.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.inputBuffer">
            <summary>
            <see cref="T:RT.Servers.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer">Input buffer</see> for this stream.
            </summary>
        </member>
        <member name="F:RT.Servers.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.baseInputStream">
            <summary>
            Base stream the inflater reads from.
            </summary>
        </member>
        <member name="F:RT.Servers.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.csize">
            <summary>
            The compressed size
            </summary>
        </member>
        <member name="F:RT.Servers.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.isClosed">
            <summary>
            Flag indicating wether this instance has been closed or not.
            </summary>
        </member>
        <member name="F:RT.Servers.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.isStreamOwner">
            <summary>
            Flag indicating wether this instance is designated the stream owner.
            When closing if this flag is true the underlying stream is closed.
            </summary>
        </member>
        <member name="P:RT.Servers.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.IsStreamOwner">
            <summary>
            Get/set flag indicating ownership of underlying stream.
            When the flag is true <see cref="M:RT.Servers.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.Close"/> will close the underlying stream also.
            </summary>
            <remarks>
            The default value is true.
            </remarks>
        </member>
        <member name="P:RT.Servers.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.Available">
            <summary>
            Returns 0 once the end of the stream (EOF) has been reached.
            Otherwise returns 1.
            </summary>
        </member>
        <member name="P:RT.Servers.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.CanRead">
            <summary>
            Gets a value indicating whether the current stream supports reading
            </summary>
        </member>
        <member name="P:RT.Servers.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.CanSeek">
            <summary>
            Gets a value of false indicating seeking is not supported for this stream.
            </summary>
        </member>
        <member name="P:RT.Servers.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.CanWrite">
            <summary>
            Gets a value of false indicating that this stream is not writeable.
            </summary>
        </member>
        <member name="P:RT.Servers.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.Length">
            <summary>
            A value representing the length of the stream in bytes.
            </summary>
        </member>
        <member name="P:RT.Servers.SharpZipLib.Zip.Compression.Streams.InflaterInputStream.Position">
            <summary>
            The current position within the stream.
            Throws a NotSupportedException when attempting to set the position
            </summary>
            <exception cref="T:System.NotSupportedException">Attempting to set the position</exception>
        </member>
        <member name="F:RT.Servers.SharpZipLib.GZip.GZipInputStream.crc">
            <summary>
            CRC-32 value for uncompressed data
            </summary>
        </member>
        <member name="F:RT.Servers.SharpZipLib.GZip.GZipInputStream.readGZIPHeader">
            <summary>
            Flag to indicate if we've read the GZIP header yet for the current member (block of compressed data).
            This is tracked per-block as the file is parsed.
            </summary>
        </member>
        <member name="M:RT.Servers.SharpZipLib.GZip.GZipInputStream.#ctor(System.IO.Stream)">
            <summary>
            Creates a GZipInputStream with the default buffer size
            </summary>
            <param name="baseInputStream">
            The stream to read compressed data from (baseInputStream GZIP format)
            </param>
        </member>
        <member name="M:RT.Servers.SharpZipLib.GZip.GZipInputStream.#ctor(System.IO.Stream,System.Int32)">
            <summary>
            Creates a GZIPInputStream with the specified buffer size
            </summary>
            <param name="baseInputStream">
            The stream to read compressed data from (baseInputStream GZIP format)
            </param>
            <param name="size">
            Size of the buffer to use
            </param>
        </member>
        <member name="M:RT.Servers.SharpZipLib.GZip.GZipInputStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads uncompressed data into an array of bytes
            </summary>
            <param name="buffer">
            The buffer to read uncompressed data into
            </param>
            <param name="offset">
            The offset indicating where the data should be placed
            </param>
            <param name="count">
            The number of uncompressed bytes to be read
            </param>
            <returns>Returns the number of bytes actually read.</returns>
        </member>
        <member name="T:RT.Servers.SharpZipLib.GZip.GZipOutputStream">
             <summary>
             This filter stream is used to compress a stream into a "GZIP" stream.
             The "GZIP" format is described in RFC 1952.
            
             author of the original java version : John Leuner
             </summary>
             <example> This sample shows how to gzip a file
             <code>
             using System;
             using System.IO;
             
             using RT.Servers.SharpZipLib.GZip;
             using RT.Servers.SharpZipLib.Core;
             
             class MainClass
             {
             	public static void Main(string[] args)
             	{
             			using (Stream s = new GZipOutputStream(File.Create(args[0] + ".gz")))
             			using (FileStream fs = File.OpenRead(args[0])) {
             				byte[] writeData = new byte[4096];
             				Streamutils.Copy(s, fs, writeData);
             			}
             		}
             	}
             }	
             </code>
             </example>
        </member>
        <member name="T:RT.Servers.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream">
            <summary>
            A special stream deflating or compressing the bytes that are
            written to it.  It uses a Deflater to perform actual deflating.<br/>
            Authors of the original java version : Tom Tromey, Jochen Hoenicke 
            </summary>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.#ctor(System.IO.Stream)">
            <summary>
            Creates a new DeflaterOutputStream with a default Deflater and default buffer size.
            </summary>
            <param name="baseOutputStream">
            the output stream where deflated output should be written.
            </param>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.#ctor(System.IO.Stream,RT.Servers.SharpZipLib.Zip.Compression.Deflater)">
            <summary>
            Creates a new DeflaterOutputStream with the given Deflater and
            default buffer size.
            </summary>
            <param name="baseOutputStream">
            the output stream where deflated output should be written.
            </param>
            <param name="deflater">
            the underlying deflater.
            </param>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.#ctor(System.IO.Stream,RT.Servers.SharpZipLib.Zip.Compression.Deflater,System.Int32)">
            <summary>
            Creates a new DeflaterOutputStream with the given Deflater and
            buffer size.
            </summary>
            <param name="baseOutputStream">
            The output stream where deflated output is written.
            </param>
            <param name="deflater">
            The underlying deflater to use
            </param>
            <param name="bufferSize">
            The buffer size in bytes to use when deflating (minimum value 512)
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            bufsize is less than or equal to zero.
            </exception>
            <exception cref="T:System.ArgumentException">
            baseOutputStream does not support writing
            </exception>
            <exception cref="T:System.ArgumentNullException">
            deflater instance is null
            </exception>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.Finish">
            <summary>
            Finishes the stream by calling finish() on the deflater. 
            </summary>
            <exception cref="T:RT.Servers.SharpZipLib.SharpZipBaseException">
            Not all input is deflated
            </exception>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.Deflate">
            <summary>
            Deflates everything in the input buffers.  This will call
            <code>def.deflate()</code> until all bytes from the input buffers
            are processed.
            </summary>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>
            Sets the current position of this stream to the given value. Not supported by this class!
            </summary>
            <param name="offset">The offset relative to the <paramref name="origin"/> to seek.</param>
            <param name="origin">The <see cref="T:System.IO.SeekOrigin"/> to seek from.</param>
            <returns>The new position in the stream.</returns>
            <exception cref="T:System.NotSupportedException">Any access</exception>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.SetLength(System.Int64)">
            <summary>
            Sets the length of this stream to the given value. Not supported by this class!
            </summary>
            <param name="value">The new stream length.</param>
            <exception cref="T:System.NotSupportedException">Any access</exception>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.ReadByte">
            <summary>
            Read a byte from stream advancing position by one
            </summary>
            <returns>The byte read cast to an int.  THe value is -1 if at the end of the stream.</returns>
            <exception cref="T:System.NotSupportedException">Any access</exception>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Read a block of bytes from stream
            </summary>
            <param name="buffer">The buffer to store read data in.</param>
            <param name="offset">The offset to start storing at.</param>
            <param name="count">The maximum number of bytes to read.</param>
            <returns>The actual number of bytes read.  Zero if end of stream is detected.</returns>
            <exception cref="T:System.NotSupportedException">Any access</exception>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
            <summary>
            Asynchronous reads are not supported a NotSupportedException is always thrown
            </summary>
            <param name="buffer">The buffer to read into.</param>
            <param name="offset">The offset to start storing data at.</param>
            <param name="count">The number of bytes to read</param>
            <param name="callback">The async callback to use.</param>
            <param name="state">The state to use.</param>
            <returns>Returns an <see cref="T:System.IAsyncResult"/></returns>
            <exception cref="T:System.NotSupportedException">Any access</exception>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
            <summary>
            Asynchronous writes arent supported, a NotSupportedException is always thrown
            </summary>
            <param name="buffer">The buffer to write.</param>
            <param name="offset">The offset to begin writing at.</param>
            <param name="count">The number of bytes to write.</param>
            <param name="callback">The <see cref="T:System.AsyncCallback"/> to use.</param>
            <param name="state">The state object.</param>
            <returns>Returns an IAsyncResult.</returns>
            <exception cref="T:System.NotSupportedException">Any access</exception>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.Flush">
            <summary>
            Flushes the stream by calling <see cref="M:RT.Servers.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.Flush">Flush</see> on the deflater and then
            on the underlying stream.  This ensures that all bytes are flushed.
            </summary>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.Close">
            <summary>
            Calls <see cref="M:RT.Servers.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.Finish"/> and closes the underlying
            stream when <see cref="P:RT.Servers.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.IsStreamOwner"></see> is true.
            </summary>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.WriteByte(System.Byte)">
            <summary>
            Writes a single byte to the compressed output stream.
            </summary>
            <param name="value">
            The byte value.
            </param>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Writes bytes from an array to the compressed stream.
            </summary>
            <param name="buffer">
            The byte array
            </param>
            <param name="offset">
            The offset into the byte array where to start.
            </param>
            <param name="count">
            The number of bytes to write.
            </param>
        </member>
        <member name="F:RT.Servers.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.buffer_">
            <summary>
            This buffer is used temporarily to retrieve the bytes from the
            deflater and write them to the underlying output stream.
            </summary>
        </member>
        <member name="F:RT.Servers.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.deflater_">
            <summary>
            The deflater which is used to deflate the stream.
            </summary>
        </member>
        <member name="F:RT.Servers.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.baseOutputStream_">
            <summary>
            Base stream the deflater depends on.
            </summary>
        </member>
        <member name="P:RT.Servers.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.IsStreamOwner">
            <summary>
            Get/set flag indicating ownership of the underlying stream.
            When the flag is true <see cref="M:RT.Servers.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.Close"></see> will close the underlying stream also.
            </summary>
        </member>
        <member name="P:RT.Servers.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.CanPatchEntries">
            <summary>
            Allows client to determine if an entry can be patched after its added
            </summary>
        </member>
        <member name="P:RT.Servers.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.CanRead">
            <summary>
            Gets value indicating stream can be read from
            </summary>
        </member>
        <member name="P:RT.Servers.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.CanSeek">
            <summary>
            Gets a value indicating if seeking is supported for this stream
            This property always returns false
            </summary>
        </member>
        <member name="P:RT.Servers.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.CanWrite">
            <summary>
            Get value indicating if this stream supports writing
            </summary>
        </member>
        <member name="P:RT.Servers.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.Length">
            <summary>
            Get current length of stream
            </summary>
        </member>
        <member name="P:RT.Servers.SharpZipLib.Zip.Compression.Streams.DeflaterOutputStream.Position">
            <summary>
            Gets the current position within the stream.
            </summary>
            <exception cref="T:System.NotSupportedException">Any attempt to set position</exception>
        </member>
        <member name="F:RT.Servers.SharpZipLib.GZip.GZipOutputStream.crc">
            <summary>
            CRC-32 value for uncompressed data
            </summary>
        </member>
        <member name="M:RT.Servers.SharpZipLib.GZip.GZipOutputStream.#ctor(System.IO.Stream)">
            <summary>
            Creates a GzipOutputStream with the default buffer size
            </summary>
            <param name="baseOutputStream">
            The stream to read data (to be compressed) from
            </param>
        </member>
        <member name="M:RT.Servers.SharpZipLib.GZip.GZipOutputStream.#ctor(System.IO.Stream,System.Int32)">
            <summary>
            Creates a GZipOutputStream with the specified buffer size
            </summary>
            <param name="baseOutputStream">
            The stream to read data (to be compressed) from
            </param>
            <param name="size">
            Size of the buffer to use
            </param>
        </member>
        <member name="M:RT.Servers.SharpZipLib.GZip.GZipOutputStream.SetLevel(System.Int32)">
            <summary>
            Sets the active compression level (1-9).  The new level will be activated
            immediately.
            </summary>
            <param name="level">The compression level to set.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Level specified is not supported.
            </exception>
            <see cref="T:RT.Servers.SharpZipLib.Zip.Compression.Deflater"/>
        </member>
        <member name="M:RT.Servers.SharpZipLib.GZip.GZipOutputStream.GetLevel">
            <summary>
            Get the current compression level.
            </summary>
            <returns>The current compression level.</returns>
        </member>
        <member name="M:RT.Servers.SharpZipLib.GZip.GZipOutputStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Write given buffer to output updating crc
            </summary>
            <param name="buffer">Buffer to write</param>
            <param name="offset">Offset of first byte in buf to write</param>
            <param name="count">Number of bytes to write</param>
        </member>
        <member name="M:RT.Servers.SharpZipLib.GZip.GZipOutputStream.Close">
            <summary>
            Writes remaining compressed output data to the output stream
            and closes it.
            </summary>
        </member>
        <member name="M:RT.Servers.SharpZipLib.GZip.GZipOutputStream.Finish">
            <summary>
            Finish compression and write any footer information required to stream
            </summary>
        </member>
        <member name="T:RT.Servers.SharpZipLib.Zip.Compression.Deflater">
             <summary>
             This is the Deflater class.  The deflater class compresses input
             with the deflate algorithm described in RFC 1951.  It has several
             compression levels and three different strategies described below.
            
             This class is <i>not</i> thread safe.  This is inherent in the API, due
             to the split of deflate and setInput.
             
             author of the original java version : Jochen Hoenicke
             </summary>
        </member>
        <member name="F:RT.Servers.SharpZipLib.Zip.Compression.Deflater.BEST_COMPRESSION">
            <summary>
            The best and slowest compression level.  This tries to find very
            long and distant string repetitions.
            </summary>
        </member>
        <member name="F:RT.Servers.SharpZipLib.Zip.Compression.Deflater.BEST_SPEED">
            <summary>
            The worst but fastest compression level.
            </summary>
        </member>
        <member name="F:RT.Servers.SharpZipLib.Zip.Compression.Deflater.DEFAULT_COMPRESSION">
            <summary>
            The default compression level.
            </summary>
        </member>
        <member name="F:RT.Servers.SharpZipLib.Zip.Compression.Deflater.NO_COMPRESSION">
            <summary>
            This level won't compress at all but output uncompressed blocks.
            </summary>
        </member>
        <member name="F:RT.Servers.SharpZipLib.Zip.Compression.Deflater.DEFLATED">
            <summary>
            The compression method.  This is the only method supported so far.
            There is no need to use this constant at all.
            </summary>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.Deflater.#ctor">
            <summary>
            Creates a new deflater with default compression level.
            </summary>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.Deflater.#ctor(System.Int32)">
            <summary>
            Creates a new deflater with given compression level.
            </summary>
            <param name="level">
            the compression level, a value between NO_COMPRESSION
            and BEST_COMPRESSION, or DEFAULT_COMPRESSION.
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException">if lvl is out of range.</exception>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.Deflater.#ctor(System.Int32,System.Boolean)">
            <summary>
            Creates a new deflater with given compression level.
            </summary>
            <param name="level">
            the compression level, a value between NO_COMPRESSION
            and BEST_COMPRESSION.
            </param>
            <param name="noZlibHeaderOrFooter">
            true, if we should suppress the Zlib/RFC1950 header at the
            beginning and the adler checksum at the end of the output.  This is
            useful for the GZIP/PKZIP formats.
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException">if lvl is out of range.</exception>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.Deflater.Reset">
            <summary>
            Resets the deflater.  The deflater acts afterwards as if it was
            just created with the same compression level and strategy as it
            had before.
            </summary>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.Deflater.Flush">
            <summary>
            Flushes the current input block.  Further calls to deflate() will
            produce enough output to inflate everything in the current input
            block.  This is not part of Sun's JDK so I have made it package
            private.  It is used by DeflaterOutputStream to implement
            flush().
            </summary>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.Deflater.Finish">
            <summary>
            Finishes the deflater with the current input block.  It is an error
            to give more input after this method was called.  This method must
            be called to force all bytes to be flushed.
            </summary>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.Deflater.SetInput(System.Byte[])">
            <summary>
            Sets the data which should be compressed next.  This should be only
            called when needsInput indicates that more input is needed.
            If you call setInput when needsInput() returns false, the
            previous input that is still pending will be thrown away.
            The given byte array should not be changed, before needsInput() returns
            true again.
            This call is equivalent to <code>setInput(input, 0, input.length)</code>.
            </summary>
            <param name="input">
            the buffer containing the input data.
            </param>
            <exception cref="T:System.InvalidOperationException">
            if the buffer was finished() or ended().
            </exception>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.Deflater.SetInput(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Sets the data which should be compressed next.  This should be
            only called when needsInput indicates that more input is needed.
            The given byte array should not be changed, before needsInput() returns
            true again.
            </summary>
            <param name="input">
            the buffer containing the input data.
            </param>
            <param name="offset">
            the start of the data.
            </param>
            <param name="count">
            the number of data bytes of input.
            </param>
            <exception cref="T:System.InvalidOperationException">
            if the buffer was Finish()ed or if previous input is still pending.
            </exception>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.Deflater.SetLevel(System.Int32)">
            <summary>
            Sets the compression level.  There is no guarantee of the exact
            position of the change, but if you call this when needsInput is
            true the change of compression level will occur somewhere near
            before the end of the so far given input.
            </summary>
            <param name="level">
            the new compression level.
            </param>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.Deflater.GetLevel">
            <summary>
            Get current compression level
            </summary>
            <returns>Returns the current compression level</returns>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.Deflater.SetStrategy(RT.Servers.SharpZipLib.Zip.Compression.DeflateStrategy)">
            <summary>
            Sets the compression strategy. Strategy is one of
            DEFAULT_STRATEGY, HUFFMAN_ONLY and FILTERED.  For the exact
            position where the strategy is changed, the same as for
            SetLevel() applies.
            </summary>
            <param name="strategy">
            The new compression strategy.
            </param>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.Deflater.Deflate(System.Byte[])">
            <summary>
            Deflates the current input block with to the given array.
            </summary>
            <param name="output">
            The buffer where compressed data is stored
            </param>
            <returns>
            The number of compressed bytes added to the output, or 0 if either
            IsNeedingInput() or IsFinished returns true or length is zero.
            </returns>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.Deflater.Deflate(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Deflates the current input block to the given array.
            </summary>
            <param name="output">
            Buffer to store the compressed data.
            </param>
            <param name="offset">
            Offset into the output array.
            </param>
            <param name="length">
            The maximum number of bytes that may be stored.
            </param>
            <returns>
            The number of compressed bytes added to the output, or 0 if either
            needsInput() or finished() returns true or length is zero.
            </returns>
            <exception cref="T:System.InvalidOperationException">
            If Finish() was previously called.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            If offset or length don't match the array length.
            </exception>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.Deflater.SetDictionary(System.Byte[])">
            <summary>
            Sets the dictionary which should be used in the deflate process.
            This call is equivalent to <code>setDictionary(dict, 0, dict.Length)</code>.
            </summary>
            <param name="dictionary">
            the dictionary.
            </param>
            <exception cref="T:System.InvalidOperationException">
            if SetInput () or Deflate () were already called or another dictionary was already set.
            </exception>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.Deflater.SetDictionary(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Sets the dictionary which should be used in the deflate process.
            The dictionary is a byte array containing strings that are
            likely to occur in the data which should be compressed.  The
            dictionary is not stored in the compressed output, only a
            checksum.  To decompress the output you need to supply the same
            dictionary again.
            </summary>
            <param name="dictionary">
            The dictionary data
            </param>
            <param name="index">
            The index where dictionary information commences.
            </param>
            <param name="count">
            The number of bytes in the dictionary.
            </param>
            <exception cref="T:System.InvalidOperationException">
            If SetInput () or Deflate() were already called or another dictionary was already set.
            </exception>
        </member>
        <member name="F:RT.Servers.SharpZipLib.Zip.Compression.Deflater.level">
            <summary>
            Compression level.
            </summary>
        </member>
        <member name="F:RT.Servers.SharpZipLib.Zip.Compression.Deflater.noZlibHeaderOrFooter">
            <summary>
            If true no Zlib/RFC1950 headers or footers are generated
            </summary>
        </member>
        <member name="F:RT.Servers.SharpZipLib.Zip.Compression.Deflater.state">
            <summary>
            The current state.
            </summary>
        </member>
        <member name="F:RT.Servers.SharpZipLib.Zip.Compression.Deflater.totalOut">
            <summary>
            The total bytes of output written.
            </summary>
        </member>
        <member name="F:RT.Servers.SharpZipLib.Zip.Compression.Deflater.pending">
            <summary>
            The pending output.
            </summary>
        </member>
        <member name="F:RT.Servers.SharpZipLib.Zip.Compression.Deflater.engine">
            <summary>
            The deflater engine.
            </summary>
        </member>
        <member name="P:RT.Servers.SharpZipLib.Zip.Compression.Deflater.Adler">
            <summary>
            Gets the current adler checksum of the data that was processed so far.
            </summary>
        </member>
        <member name="P:RT.Servers.SharpZipLib.Zip.Compression.Deflater.TotalIn">
            <summary>
            Gets the number of input bytes processed so far.
            </summary>
        </member>
        <member name="P:RT.Servers.SharpZipLib.Zip.Compression.Deflater.TotalOut">
            <summary>
            Gets the number of output bytes so far.
            </summary>
        </member>
        <member name="P:RT.Servers.SharpZipLib.Zip.Compression.Deflater.IsFinished">
            <summary>
            Returns true if the stream was finished and no more output bytes
            are available.
            </summary>
        </member>
        <member name="P:RT.Servers.SharpZipLib.Zip.Compression.Deflater.IsNeedingInput">
            <summary>
            Returns true, if the input buffer is empty.
            You should then call setInput(). 
            NOTE: This method can also return true when the stream
            was finished.
            </summary>
        </member>
        <member name="T:RT.Servers.SharpZipLib.Zip.Compression.DeflaterConstants">
            <summary>
            This class contains constants used for deflation.
            </summary>
        </member>
        <member name="F:RT.Servers.SharpZipLib.Zip.Compression.DeflaterConstants.DEBUGGING">
            <summary>
            Set to true to enable debugging
            </summary>
        </member>
        <member name="F:RT.Servers.SharpZipLib.Zip.Compression.DeflaterConstants.STORED_BLOCK">
            <summary>
            Written to Zip file to identify a stored block
            </summary>
        </member>
        <member name="F:RT.Servers.SharpZipLib.Zip.Compression.DeflaterConstants.STATIC_TREES">
            <summary>
            Identifies static tree in Zip file
            </summary>
        </member>
        <member name="F:RT.Servers.SharpZipLib.Zip.Compression.DeflaterConstants.DYN_TREES">
            <summary>
            Identifies dynamic tree in Zip file
            </summary>
        </member>
        <member name="F:RT.Servers.SharpZipLib.Zip.Compression.DeflaterConstants.PRESET_DICT">
            <summary>
            Header flag indicating a preset dictionary for deflation
            </summary>
        </member>
        <member name="F:RT.Servers.SharpZipLib.Zip.Compression.DeflaterConstants.DEFAULT_MEM_LEVEL">
            <summary>
            Sets internal buffer sizes for Huffman encoding
            </summary>
        </member>
        <member name="F:RT.Servers.SharpZipLib.Zip.Compression.DeflaterConstants.MAX_MATCH">
            <summary>
            Internal compression engine constant
            </summary>		
        </member>
        <member name="F:RT.Servers.SharpZipLib.Zip.Compression.DeflaterConstants.MIN_MATCH">
            <summary>
            Internal compression engine constant
            </summary>		
        </member>
        <member name="F:RT.Servers.SharpZipLib.Zip.Compression.DeflaterConstants.MAX_WBITS">
            <summary>
            Internal compression engine constant
            </summary>		
        </member>
        <member name="F:RT.Servers.SharpZipLib.Zip.Compression.DeflaterConstants.WSIZE">
            <summary>
            Internal compression engine constant
            </summary>		
        </member>
        <member name="F:RT.Servers.SharpZipLib.Zip.Compression.DeflaterConstants.WMASK">
            <summary>
            Internal compression engine constant
            </summary>		
        </member>
        <member name="F:RT.Servers.SharpZipLib.Zip.Compression.DeflaterConstants.HASH_BITS">
            <summary>
            Internal compression engine constant
            </summary>		
        </member>
        <member name="F:RT.Servers.SharpZipLib.Zip.Compression.DeflaterConstants.HASH_SIZE">
            <summary>
            Internal compression engine constant
            </summary>		
        </member>
        <member name="F:RT.Servers.SharpZipLib.Zip.Compression.DeflaterConstants.HASH_MASK">
            <summary>
            Internal compression engine constant
            </summary>		
        </member>
        <member name="F:RT.Servers.SharpZipLib.Zip.Compression.DeflaterConstants.HASH_SHIFT">
            <summary>
            Internal compression engine constant
            </summary>		
        </member>
        <member name="F:RT.Servers.SharpZipLib.Zip.Compression.DeflaterConstants.MIN_LOOKAHEAD">
            <summary>
            Internal compression engine constant
            </summary>		
        </member>
        <member name="F:RT.Servers.SharpZipLib.Zip.Compression.DeflaterConstants.MAX_DIST">
            <summary>
            Internal compression engine constant
            </summary>		
        </member>
        <member name="F:RT.Servers.SharpZipLib.Zip.Compression.DeflaterConstants.PENDING_BUF_SIZE">
            <summary>
            Internal compression engine constant
            </summary>		
        </member>
        <member name="F:RT.Servers.SharpZipLib.Zip.Compression.DeflaterConstants.DEFLATE_STORED">
            <summary>
            Internal compression engine constant
            </summary>		
        </member>
        <member name="F:RT.Servers.SharpZipLib.Zip.Compression.DeflaterConstants.DEFLATE_FAST">
            <summary>
            Internal compression engine constant
            </summary>		
        </member>
        <member name="F:RT.Servers.SharpZipLib.Zip.Compression.DeflaterConstants.DEFLATE_SLOW">
            <summary>
            Internal compression engine constant
            </summary>		
        </member>
        <member name="F:RT.Servers.SharpZipLib.Zip.Compression.DeflaterConstants.MAX_BLOCK_SIZE">
            <summary>
            Internal compression engine constant
            </summary>		
        </member>
        <member name="F:RT.Servers.SharpZipLib.Zip.Compression.DeflaterConstants.GOOD_LENGTH">
            <summary>
            Internal compression engine constant
            </summary>		
        </member>
        <member name="F:RT.Servers.SharpZipLib.Zip.Compression.DeflaterConstants.MAX_LAZY">
            <summary>
            Internal compression engine constant
            </summary>		
        </member>
        <member name="F:RT.Servers.SharpZipLib.Zip.Compression.DeflaterConstants.NICE_LENGTH">
            <summary>
            Internal compression engine constant
            </summary>		
        </member>
        <member name="F:RT.Servers.SharpZipLib.Zip.Compression.DeflaterConstants.MAX_CHAIN">
            <summary>
            Internal compression engine constant
            </summary>		
        </member>
        <member name="F:RT.Servers.SharpZipLib.Zip.Compression.DeflaterConstants.COMPR_FUNC">
            <summary>
            Internal compression engine constant
            </summary>		
        </member>
        <member name="T:RT.Servers.SharpZipLib.Zip.Compression.DeflateStrategy">
            <summary>
            Strategies for deflater
            </summary>
        </member>
        <member name="F:RT.Servers.SharpZipLib.Zip.Compression.DeflateStrategy.Default">
            <summary>
            The default strategy
            </summary>
        </member>
        <member name="F:RT.Servers.SharpZipLib.Zip.Compression.DeflateStrategy.Filtered">
            <summary>
            This strategy will only allow longer string repetitions.  It is
            useful for random data with a small character set.
            </summary>
        </member>
        <member name="F:RT.Servers.SharpZipLib.Zip.Compression.DeflateStrategy.HuffmanOnly">
            <summary>
            This strategy will not look for string repetitions at all.  It
            only encodes with Huffman trees (which means, that more common
            characters get a smaller encoding.
            </summary>
        </member>
        <member name="T:RT.Servers.SharpZipLib.Zip.Compression.DeflaterEngine">
            <summary>
            Low level compression engine for deflate algorithm which uses a 32K sliding window
            with secondary compression from Huffman/Shannon-Fano codes.
            </summary>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.DeflaterEngine.#ctor(RT.Servers.SharpZipLib.Zip.Compression.DeflaterPending)">
            <summary>
            Construct instance with pending buffer
            </summary>
            <param name="pending">
            Pending buffer to use
            </param>>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.DeflaterEngine.Deflate(System.Boolean,System.Boolean)">
            <summary>
            Deflate drives actual compression of data
            </summary>
            <param name="flush">True to flush input buffers</param>
            <param name="finish">Finish deflation with the current input.</param>
            <returns>Returns true if progress has been made.</returns>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.DeflaterEngine.SetInput(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Sets input data to be deflated.  Should only be called when <code>NeedsInput()</code>
            returns true
            </summary>
            <param name="buffer">The buffer containing input data.</param>
            <param name="offset">The offset of the first byte of data.</param>
            <param name="count">The number of bytes of data to use as input.</param>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.DeflaterEngine.NeedsInput">
            <summary>
            Determines if more <see cref="M:RT.Servers.SharpZipLib.Zip.Compression.DeflaterEngine.SetInput(System.Byte[],System.Int32,System.Int32)">input</see> is needed.
            </summary>		
            <returns>Return true if input is needed via <see cref="M:RT.Servers.SharpZipLib.Zip.Compression.DeflaterEngine.SetInput(System.Byte[],System.Int32,System.Int32)">SetInput</see></returns>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.DeflaterEngine.SetDictionary(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Set compression dictionary
            </summary>
            <param name="buffer">The buffer containing the dictionary data</param>
            <param name="offset">The offset in the buffer for the first byte of data</param>
            <param name="length">The length of the dictionary data.</param>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.DeflaterEngine.Reset">
            <summary>
            Reset internal state
            </summary>		
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.DeflaterEngine.ResetAdler">
            <summary>
            Reset Adler checksum
            </summary>		
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.DeflaterEngine.SetLevel(System.Int32)">
            <summary>
            Set the deflate level (0-9)
            </summary>
            <param name="level">The value to set the level to.</param>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.DeflaterEngine.FillWindow">
            <summary>
            Fill the window
            </summary>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.DeflaterEngine.InsertString">
            <summary>
            Inserts the current string in the head hash and returns the previous
            value for this hash.
            </summary>
            <returns>The previous hash value</returns>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.DeflaterEngine.FindLongestMatch(System.Int32)">
             <summary>
             Find the best (longest) string in the window matching the 
             string starting at strstart.
            
             Preconditions:
             <code>
             strstart + MAX_MATCH &lt;= window.length.</code>
             </summary>
             <param name="curMatch"></param>
             <returns>True if a match greater than the minimum length is found</returns>
        </member>
        <member name="F:RT.Servers.SharpZipLib.Zip.Compression.DeflaterEngine.head">
            <summary>
            Hashtable, hashing three characters to an index for window, so
            that window[index]..window[index+2] have this hash code.  
            Note that the array should really be unsigned short, so you need
            to and the values with 0xffff.
            </summary>
        </member>
        <member name="F:RT.Servers.SharpZipLib.Zip.Compression.DeflaterEngine.prev">
            <summary>
            <code>prev[index &amp; WMASK]</code> points to the previous index that has the
            same hash code as the string starting at index.  This way 
            entries with the same hash code are in a linked list.
            Note that the array should really be unsigned short, so you need
            to and the values with 0xffff.
            </summary>
        </member>
        <member name="F:RT.Servers.SharpZipLib.Zip.Compression.DeflaterEngine.strstart">
            <summary>
            Points to the current character in the window.
            </summary>
        </member>
        <member name="F:RT.Servers.SharpZipLib.Zip.Compression.DeflaterEngine.lookahead">
            <summary>
            lookahead is the number of characters starting at strstart in
            window that are valid.
            So window[strstart] until window[strstart+lookahead-1] are valid
            characters.
            </summary>
        </member>
        <member name="F:RT.Servers.SharpZipLib.Zip.Compression.DeflaterEngine.window">
            <summary>
            This array contains the part of the uncompressed stream that 
            is of relevance.  The current character is indexed by strstart.
            </summary>
        </member>
        <member name="F:RT.Servers.SharpZipLib.Zip.Compression.DeflaterEngine.compressionFunction">
            <summary>
            The current compression function.
            </summary>
        </member>
        <member name="F:RT.Servers.SharpZipLib.Zip.Compression.DeflaterEngine.inputBuf">
            <summary>
            The input data for compression.
            </summary>
        </member>
        <member name="F:RT.Servers.SharpZipLib.Zip.Compression.DeflaterEngine.totalIn">
            <summary>
            The total bytes of input read.
            </summary>
        </member>
        <member name="F:RT.Servers.SharpZipLib.Zip.Compression.DeflaterEngine.inputOff">
            <summary>
            The offset into inputBuf, where input data starts.
            </summary>
        </member>
        <member name="F:RT.Servers.SharpZipLib.Zip.Compression.DeflaterEngine.inputEnd">
            <summary>
            The end offset of the input data.
            </summary>
        </member>
        <member name="F:RT.Servers.SharpZipLib.Zip.Compression.DeflaterEngine.adler">
            <summary>
            The adler checksum
            </summary>
        </member>
        <member name="P:RT.Servers.SharpZipLib.Zip.Compression.DeflaterEngine.Adler">
            <summary>
            Get current value of Adler checksum
            </summary>		
        </member>
        <member name="P:RT.Servers.SharpZipLib.Zip.Compression.DeflaterEngine.TotalIn">
            <summary>
            Total data processed
            </summary>		
        </member>
        <member name="P:RT.Servers.SharpZipLib.Zip.Compression.DeflaterEngine.Strategy">
            <summary>
            Get/set the <see cref="T:RT.Servers.SharpZipLib.Zip.Compression.DeflateStrategy">deflate strategy</see>
            </summary>		
        </member>
        <member name="T:RT.Servers.SharpZipLib.Zip.Compression.DeflaterHuffman">
            <summary>
            This is the DeflaterHuffman class.
            
            This class is <i>not</i> thread safe.  This is inherent in the API, due
            to the split of Deflate and SetInput.
            
            author of the original java version : Jochen Hoenicke
            </summary>
        </member>
        <member name="F:RT.Servers.SharpZipLib.Zip.Compression.DeflaterHuffman.pending">
            <summary>
            Pending buffer to use
            </summary>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.DeflaterHuffman.#ctor(RT.Servers.SharpZipLib.Zip.Compression.DeflaterPending)">
            <summary>
            Construct instance with pending buffer
            </summary>
            <param name="pending">Pending buffer to use</param>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.DeflaterHuffman.Reset">
            <summary>
            Reset internal state
            </summary>		
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.DeflaterHuffman.SendAllTrees(System.Int32)">
            <summary>
            Write all trees to pending buffer
            </summary>
            <param name="blTreeCodes">The number/rank of treecodes to send.</param>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.DeflaterHuffman.CompressBlock">
            <summary>
            Compress current buffer writing data to pending buffer
            </summary>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.DeflaterHuffman.FlushStoredBlock(System.Byte[],System.Int32,System.Int32,System.Boolean)">
            <summary>
            Flush block to output with no compression
            </summary>
            <param name="stored">Data to write</param>
            <param name="storedOffset">Index of first byte to write</param>
            <param name="storedLength">Count of bytes to write</param>
            <param name="lastBlock">True if this is the last block</param>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.DeflaterHuffman.FlushBlock(System.Byte[],System.Int32,System.Int32,System.Boolean)">
            <summary>
            Flush block to output with compression
            </summary>		
            <param name="stored">Data to flush</param>
            <param name="storedOffset">Index of first byte to flush</param>
            <param name="storedLength">Count of bytes to flush</param>
            <param name="lastBlock">True if this is the last block</param>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.DeflaterHuffman.IsFull">
            <summary>
            Get value indicating if internal buffer is full
            </summary>
            <returns>true if buffer is full</returns>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.DeflaterHuffman.TallyLit(System.Int32)">
            <summary>
            Add literal to buffer
            </summary>
            <param name="literal">Literal value to add to buffer.</param>
            <returns>Value indicating internal buffer is full</returns>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.DeflaterHuffman.TallyDist(System.Int32,System.Int32)">
            <summary>
            Add distance code and length to literal and distance trees
            </summary>
            <param name="distance">Distance code</param>
            <param name="length">Length</param>
            <returns>Value indicating if internal buffer is full</returns>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.DeflaterHuffman.BitReverse(System.Int32)">
            <summary>
            Reverse the bits of a 16 bit value.
            </summary>
            <param name="toReverse">Value to reverse bits</param>
            <returns>Value with bits reversed</returns>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.DeflaterHuffman.Tree.Reset">
            <summary>
            Resets the internal state of the tree
            </summary>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.DeflaterHuffman.Tree.CheckEmpty">
            <summary>
            Check that all frequencies are zero
            </summary>
            <exception cref="T:RT.Servers.SharpZipLib.SharpZipBaseException">
            At least one frequency is non-zero
            </exception>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.DeflaterHuffman.Tree.SetStaticCodes(System.Int16[],System.Byte[])">
            <summary>
            Set static codes and length
            </summary>
            <param name="staticCodes">new codes</param>
            <param name="staticLengths">length for new codes</param>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.DeflaterHuffman.Tree.BuildCodes">
            <summary>
            Build dynamic codes and lengths
            </summary>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.DeflaterHuffman.Tree.GetEncodedLength">
            <summary>
            Get encoded length
            </summary>
            <returns>Encoded length, the sum of frequencies * lengths</returns>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.DeflaterHuffman.Tree.CalcBLFreq(RT.Servers.SharpZipLib.Zip.Compression.DeflaterHuffman.Tree)">
            <summary>
            Scan a literal or distance tree to determine the frequencies of the codes
            in the bit length tree.
            </summary>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.DeflaterHuffman.Tree.WriteTree(RT.Servers.SharpZipLib.Zip.Compression.DeflaterHuffman.Tree)">
            <summary>
            Write tree values
            </summary>
            <param name="blTree">Tree to write</param>
        </member>
        <member name="T:RT.Servers.SharpZipLib.Zip.Compression.DeflaterPending">
            <summary>
            This class stores the pending output of the Deflater.
            
            author of the original java version : Jochen Hoenicke
            </summary>
        </member>
        <member name="T:RT.Servers.SharpZipLib.Zip.Compression.PendingBuffer">
            <summary>
            This class is general purpose class for writing data to a buffer.
            
            It allows you to write bits as well as bytes
            Based on DeflaterPending.java
            
            author of the original java version : Jochen Hoenicke
            </summary>
        </member>
        <member name="F:RT.Servers.SharpZipLib.Zip.Compression.PendingBuffer.buffer_">
            <summary>
            Internal work buffer
            </summary>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.PendingBuffer.#ctor">
            <summary>
            construct instance using default buffer size of 4096
            </summary>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.PendingBuffer.#ctor(System.Int32)">
            <summary>
            construct instance using specified buffer size
            </summary>
            <param name="bufferSize">
            size to use for internal buffer
            </param>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.PendingBuffer.Reset">
            <summary>
            Clear internal state/buffers
            </summary>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.PendingBuffer.WriteByte(System.Int32)">
            <summary>
            Write a byte to buffer
            </summary>
            <param name="value">
            The value to write
            </param>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.PendingBuffer.WriteShort(System.Int32)">
            <summary>
            Write a short value to buffer LSB first
            </summary>
            <param name="value">
            The value to write.
            </param>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.PendingBuffer.WriteInt(System.Int32)">
            <summary>
            write an integer LSB first
            </summary>
            <param name="value">The value to write.</param>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.PendingBuffer.WriteBlock(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Write a block of data to buffer
            </summary>
            <param name="block">data to write</param>
            <param name="offset">offset of first byte to write</param>
            <param name="length">number of bytes to write</param>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.PendingBuffer.AlignToByte">
            <summary>
            Align internal buffer on a byte boundary
            </summary>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.PendingBuffer.WriteBits(System.Int32,System.Int32)">
            <summary>
            Write bits to internal buffer
            </summary>
            <param name="b">source of bits</param>
            <param name="count">number of bits to write</param>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.PendingBuffer.WriteShortMSB(System.Int32)">
            <summary>
            Write a short value to internal buffer most significant byte first
            </summary>
            <param name="s">value to write</param>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.PendingBuffer.Flush(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Flushes the pending buffer into the given output array.  If the
            output array is to small, only a partial flush is done.
            </summary>
            <param name="output">The output array.</param>
            <param name="offset">The offset into output array.</param>
            <param name="length">The maximum number of bytes to store.</param>
            <returns>The number of bytes flushed.</returns>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.PendingBuffer.ToByteArray">
            <summary>
            Convert internal buffer to byte array.
            Buffer is empty on completion
            </summary>
            <returns>
            The internal buffer contents converted to a byte array.
            </returns>
        </member>
        <member name="P:RT.Servers.SharpZipLib.Zip.Compression.PendingBuffer.BitCount">
            <summary>
            The number of bits written to the buffer
            </summary>
        </member>
        <member name="P:RT.Servers.SharpZipLib.Zip.Compression.PendingBuffer.IsFlushed">
            <summary>
            Indicates if buffer has been flushed
            </summary>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.DeflaterPending.#ctor">
            <summary>
            Construct instance with default buffer size
            </summary>
        </member>
        <member name="T:RT.Servers.SharpZipLib.Zip.Compression.Inflater">
             <summary>
             Inflater is used to decompress data that has been compressed according
             to the "deflate" standard described in rfc1951.
             
             By default Zlib (rfc1950) headers and footers are expected in the input.
             You can use constructor <code> public Inflater(bool noHeader)</code> passing true
             if there is no Zlib header information
            
             The usage is as following.  First you have to set some input with
             <code>SetInput()</code>, then Inflate() it.  If inflate doesn't
             inflate any bytes there may be three reasons:
             <ul>
             <li>IsNeedingInput() returns true because the input buffer is empty.
             You have to provide more input with <code>SetInput()</code>.
             NOTE: IsNeedingInput() also returns true when, the stream is finished.
             </li>
             <li>IsNeedingDictionary() returns true, you have to provide a preset
                dictionary with <code>SetDictionary()</code>.</li>
             <li>IsFinished returns true, the inflater has finished.</li>
             </ul>
             Once the first output byte is produced, a dictionary will not be
             needed at a later stage.
            
             author of the original java version : John Leuner, Jochen Hoenicke
             </summary>
        </member>
        <member name="F:RT.Servers.SharpZipLib.Zip.Compression.Inflater.DECODE_HEADER">
            <summary>
            These are the possible states for an inflater
            </summary>
        </member>
        <member name="F:RT.Servers.SharpZipLib.Zip.Compression.Inflater.CPLENS">
            <summary>
            Copy lengths for literal codes 257..285
            </summary>
        </member>
        <member name="F:RT.Servers.SharpZipLib.Zip.Compression.Inflater.CPLEXT">
            <summary>
            Extra bits for literal codes 257..285
            </summary>
        </member>
        <member name="F:RT.Servers.SharpZipLib.Zip.Compression.Inflater.CPDIST">
            <summary>
            Copy offsets for distance codes 0..29
            </summary>
        </member>
        <member name="F:RT.Servers.SharpZipLib.Zip.Compression.Inflater.CPDEXT">
            <summary>
            Extra bits for distance codes
            </summary>
        </member>
        <member name="F:RT.Servers.SharpZipLib.Zip.Compression.Inflater.mode">
            <summary>
            This variable contains the current state.
            </summary>
        </member>
        <member name="F:RT.Servers.SharpZipLib.Zip.Compression.Inflater.readAdler">
            <summary>
            The adler checksum of the dictionary or of the decompressed
            stream, as it is written in the header resp. footer of the
            compressed stream. 
            Only valid if mode is DECODE_DICT or DECODE_CHKSUM.
            </summary>
        </member>
        <member name="F:RT.Servers.SharpZipLib.Zip.Compression.Inflater.neededBits">
            <summary>
            The number of bits needed to complete the current state.  This
            is valid, if mode is DECODE_DICT, DECODE_CHKSUM,
            DECODE_HUFFMAN_LENBITS or DECODE_HUFFMAN_DISTBITS.
            </summary>
        </member>
        <member name="F:RT.Servers.SharpZipLib.Zip.Compression.Inflater.isLastBlock">
            <summary>
            True, if the last block flag was set in the last block of the
            inflated stream.  This means that the stream ends after the
            current block.
            </summary>
        </member>
        <member name="F:RT.Servers.SharpZipLib.Zip.Compression.Inflater.totalOut">
            <summary>
            The total number of inflated bytes.
            </summary>
        </member>
        <member name="F:RT.Servers.SharpZipLib.Zip.Compression.Inflater.totalIn">
            <summary>
            The total number of bytes set with setInput().  This is not the
            value returned by the TotalIn property, since this also includes the
            unprocessed input.
            </summary>
        </member>
        <member name="F:RT.Servers.SharpZipLib.Zip.Compression.Inflater.noHeader">
            <summary>
            This variable stores the noHeader flag that was given to the constructor.
            True means, that the inflated stream doesn't contain a Zlib header or 
            footer.
            </summary>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.Inflater.#ctor">
            <summary>
            Creates a new inflater or RFC1951 decompressor
            RFC1950/Zlib headers and footers will be expected in the input data
            </summary>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.Inflater.#ctor(System.Boolean)">
            <summary>
            Creates a new inflater.
            </summary>
            <param name="noHeader">
            True if no RFC1950/Zlib header and footer fields are expected in the input data
            
            This is used for GZIPed/Zipped input.
            
            For compatibility with
            Sun JDK you should provide one byte of input more than needed in
            this case.
            </param>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.Inflater.Reset">
            <summary>
            Resets the inflater so that a new stream can be decompressed.  All
            pending input and output will be discarded.
            </summary>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.Inflater.DecodeHeader">
            <summary>
            Decodes a zlib/RFC1950 header.
            </summary>
            <returns>
            False if more input is needed.
            </returns>
            <exception cref="T:RT.Servers.SharpZipLib.SharpZipBaseException">
            The header is invalid.
            </exception>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.Inflater.DecodeDict">
            <summary>
            Decodes the dictionary checksum after the deflate header.
            </summary>
            <returns>
            False if more input is needed.
            </returns>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.Inflater.DecodeHuffman">
            <summary>
            Decodes the huffman encoded symbols in the input stream.
            </summary>
            <returns>
            false if more input is needed, true if output window is
            full or the current block ends.
            </returns>
            <exception cref="T:RT.Servers.SharpZipLib.SharpZipBaseException">
            if deflated stream is invalid.
            </exception>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.Inflater.DecodeChksum">
            <summary>
            Decodes the adler checksum after the deflate stream.
            </summary>
            <returns>
            false if more input is needed.
            </returns>
            <exception cref="T:RT.Servers.SharpZipLib.SharpZipBaseException">
            If checksum doesn't match.
            </exception>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.Inflater.Decode">
            <summary>
            Decodes the deflated stream.
            </summary>
            <returns>
            false if more input is needed, or if finished.
            </returns>
            <exception cref="T:RT.Servers.SharpZipLib.SharpZipBaseException">
            if deflated stream is invalid.
            </exception>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.Inflater.SetDictionary(System.Byte[])">
            <summary>
            Sets the preset dictionary.  This should only be called, if
            needsDictionary() returns true and it should set the same
            dictionary, that was used for deflating.  The getAdler()
            function returns the checksum of the dictionary needed.
            </summary>
            <param name="buffer">
            The dictionary.
            </param>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.Inflater.SetDictionary(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Sets the preset dictionary.  This should only be called, if
            needsDictionary() returns true and it should set the same
            dictionary, that was used for deflating.  The getAdler()
            function returns the checksum of the dictionary needed.
            </summary>
            <param name="buffer">
            The dictionary.
            </param>
            <param name="index">
            The index into buffer where the dictionary starts.
            </param>
            <param name="count">
            The number of bytes in the dictionary.
            </param>
            <exception cref="T:System.InvalidOperationException">
            No dictionary is needed.
            </exception>
            <exception cref="T:RT.Servers.SharpZipLib.SharpZipBaseException">
            The adler checksum for the buffer is invalid
            </exception>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.Inflater.SetInput(System.Byte[])">
            <summary>
            Sets the input.  This should only be called, if needsInput()
            returns true.
            </summary>
            <param name="buffer">
            the input.
            </param>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.Inflater.SetInput(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Sets the input.  This should only be called, if needsInput()
            returns true.
            </summary>
            <param name="buffer">
            The source of input data
            </param>
            <param name="index">
            The index into buffer where the input starts.
            </param>
            <param name="count">
            The number of bytes of input to use.
            </param>
            <exception cref="T:System.InvalidOperationException">
            No input is needed.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The index and/or count are wrong.
            </exception>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.Inflater.Inflate(System.Byte[])">
            <summary>
            Inflates the compressed stream to the output buffer.  If this
            returns 0, you should check, whether IsNeedingDictionary(),
            IsNeedingInput() or IsFinished() returns true, to determine why no
            further output is produced.
            </summary>
            <param name="buffer">
            the output buffer.
            </param>
            <returns>
            The number of bytes written to the buffer, 0 if no further
            output can be produced.
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            if buffer has length 0.
            </exception>
            <exception cref="T:System.FormatException">
            if deflated stream is invalid.
            </exception>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.Inflater.Inflate(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Inflates the compressed stream to the output buffer.  If this
            returns 0, you should check, whether needsDictionary(),
            needsInput() or finished() returns true, to determine why no
            further output is produced.
            </summary>
            <param name="buffer">
            the output buffer.
            </param>
            <param name="offset">
            the offset in buffer where storing starts.
            </param>
            <param name="count">
            the maximum number of bytes to output.
            </param>
            <returns>
            the number of bytes written to the buffer, 0 if no further output can be produced.
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            if count is less than 0.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            if the index and / or count are wrong.
            </exception>
            <exception cref="T:System.FormatException">
            if deflated stream is invalid.
            </exception>
        </member>
        <member name="P:RT.Servers.SharpZipLib.Zip.Compression.Inflater.IsNeedingInput">
            <summary>
            Returns true, if the input buffer is empty.
            You should then call setInput(). 
            NOTE: This method also returns true when the stream is finished.
            </summary>
        </member>
        <member name="P:RT.Servers.SharpZipLib.Zip.Compression.Inflater.IsNeedingDictionary">
            <summary>
            Returns true, if a preset dictionary is needed to inflate the input.
            </summary>
        </member>
        <member name="P:RT.Servers.SharpZipLib.Zip.Compression.Inflater.IsFinished">
            <summary>
            Returns true, if the inflater has finished.  This means, that no
            input is needed and no output can be produced.
            </summary>
        </member>
        <member name="P:RT.Servers.SharpZipLib.Zip.Compression.Inflater.Adler">
            <summary>
            Gets the adler checksum.  This is either the checksum of all
            uncompressed bytes returned by inflate(), or if needsDictionary()
            returns true (and thus no output was yet produced) this is the
            adler checksum of the expected dictionary.
            </summary>
            <returns>
            the adler checksum.
            </returns>
        </member>
        <member name="P:RT.Servers.SharpZipLib.Zip.Compression.Inflater.TotalOut">
            <summary>
            Gets the total number of output bytes returned by Inflate().
            </summary>
            <returns>
            the total number of output bytes.
            </returns>
        </member>
        <member name="P:RT.Servers.SharpZipLib.Zip.Compression.Inflater.TotalIn">
            <summary>
            Gets the total number of processed compressed input bytes.
            </summary>
            <returns>
            The total number of bytes of processed input bytes.
            </returns>
        </member>
        <member name="P:RT.Servers.SharpZipLib.Zip.Compression.Inflater.RemainingInput">
            <summary>
            Gets the number of unprocessed input bytes.  Useful, if the end of the
            stream is reached and you want to further process the bytes after
            the deflate stream.
            </summary>
            <returns>
            The number of bytes of the input which have not been processed.
            </returns>
        </member>
        <member name="F:RT.Servers.SharpZipLib.Zip.Compression.InflaterDynHeader.mode">
            <summary>
            The current decode mode
            </summary>
        </member>
        <member name="T:RT.Servers.SharpZipLib.Zip.Compression.InflaterHuffmanTree">
            <summary>
            Huffman tree used for inflation
            </summary>
        </member>
        <member name="F:RT.Servers.SharpZipLib.Zip.Compression.InflaterHuffmanTree.defLitLenTree">
            <summary>
            Literal length tree
            </summary>
        </member>
        <member name="F:RT.Servers.SharpZipLib.Zip.Compression.InflaterHuffmanTree.defDistTree">
            <summary>
            Distance tree
            </summary>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.InflaterHuffmanTree.#ctor(System.Byte[])">
            <summary>
            Constructs a Huffman tree from the array of code lengths.
            </summary>
            <param name = "codeLengths">
            the array of code lengths
            </param>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.InflaterHuffmanTree.GetSymbol(RT.Servers.SharpZipLib.Zip.Compression.Streams.StreamManipulator)">
            <summary>
            Reads the next symbol from input.  The symbol is encoded using the
            huffman tree.
            </summary>
            <param name="input">
            input the input source.
            </param>
            <returns>
            the next symbol, or -1 if not enough input is available.
            </returns>
        </member>
        <member name="T:RT.Servers.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer">
            <summary>
            An input buffer customised for use by <see cref="T:RT.Servers.SharpZipLib.Zip.Compression.Streams.InflaterInputStream"/>
            </summary>
            <remarks>
            The buffer supports decryption of incoming data.
            </remarks>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.#ctor(System.IO.Stream)">
            <summary>
            Initialise a new instance of <see cref="T:RT.Servers.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer"/> with a default buffer size
            </summary>
            <param name="stream">The stream to buffer.</param>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.#ctor(System.IO.Stream,System.Int32)">
            <summary>
            Initialise a new instance of <see cref="T:RT.Servers.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer"/>
            </summary>
            <param name="stream">The stream to buffer.</param>
            <param name="bufferSize">The size to use for the buffer</param>
            <remarks>A minimum buffer size of 1KB is permitted.  Lower sizes are treated as 1KB.</remarks>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.SetInflaterInput(RT.Servers.SharpZipLib.Zip.Compression.Inflater)">
            <summary>
            Call <see cref="M:RT.Servers.SharpZipLib.Zip.Compression.Inflater.SetInput(System.Byte[],System.Int32,System.Int32)"/> passing the current clear text buffer contents.
            </summary>
            <param name="inflater">The inflater to set input for.</param>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.Fill">
            <summary>
            Fill the buffer from the underlying input stream.
            </summary>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.ReadRawBuffer(System.Byte[])">
            <summary>
            Read a buffer directly from the input stream
            </summary>
            <param name="buffer">The buffer to fill</param>
            <returns>Returns the number of bytes read.</returns>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.ReadRawBuffer(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Read a buffer directly from the input stream
            </summary>
            <param name="outBuffer">The buffer to read into</param>
            <param name="offset">The offset to start reading data into.</param>
            <param name="length">The number of bytes to read.</param>
            <returns>Returns the number of bytes read.</returns>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.ReadClearTextBuffer(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Read clear text data from the input stream.
            </summary>
            <param name="outBuffer">The buffer to add data to.</param>
            <param name="offset">The offset to start adding data at.</param>
            <param name="length">The number of bytes to read.</param>
            <returns>Returns the number of bytes actually read.</returns>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.ReadLeByte">
            <summary>
            Read a <see cref="T:System.Byte"/> from the input stream.
            </summary>
            <returns>Returns the byte read.</returns>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.ReadLeShort">
            <summary>
            Read an <see cref="T:System.Int16"/> in little endian byte order.
            </summary>
            <returns>The short value read case to an int.</returns>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.ReadLeInt">
            <summary>
            Read an <see cref="T:System.Int32"/> in little endian byte order.
            </summary>
            <returns>The int value read.</returns>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.ReadLeLong">
            <summary>
            Read a <see cref="T:System.Int64"/> in little endian byte order.
            </summary>
            <returns>The long value read.</returns>
        </member>
        <member name="P:RT.Servers.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.RawLength">
            <summary>
            Get the length of bytes bytes in the <see cref="P:RT.Servers.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.RawData"/>
            </summary>
        </member>
        <member name="P:RT.Servers.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.RawData">
            <summary>
            Get the contents of the raw data buffer.
            </summary>
            <remarks>This may contain encrypted data.</remarks>
        </member>
        <member name="P:RT.Servers.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.ClearTextLength">
            <summary>
            Get the number of useable bytes in <see cref="P:RT.Servers.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.ClearText"/>
            </summary>
        </member>
        <member name="P:RT.Servers.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.ClearText">
            <summary>
            Get the contents of the clear text buffer.
            </summary>
        </member>
        <member name="P:RT.Servers.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.Available">
            <summary>
            Get/set the number of bytes available
            </summary>
        </member>
        <member name="P:RT.Servers.SharpZipLib.Zip.Compression.Streams.InflaterInputBuffer.CryptoTransform">
            <summary>
            Get/set the <see cref="T:System.Security.Cryptography.ICryptoTransform"/> to apply to any data.
            </summary>
            <remarks>Set this value to null to have no transform applied.</remarks>
        </member>
        <member name="T:RT.Servers.SharpZipLib.Zip.Compression.Streams.OutputWindow">
            <summary>
            Contains the output from the Inflation process.
            We need to have a window so that we can refer backwards into the output stream
            to repeat stuff.<br/>
            Author of the original java version : John Leuner
            </summary>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.Streams.OutputWindow.Write(System.Int32)">
            <summary>
            Write a byte to this output window
            </summary>
            <param name="value">value to write</param>
            <exception cref="T:System.InvalidOperationException">
            if window is full
            </exception>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.Streams.OutputWindow.Repeat(System.Int32,System.Int32)">
            <summary>
            Append a byte pattern already in the window itself
            </summary>
            <param name="length">length of pattern to copy</param>
            <param name="distance">distance from end of window pattern occurs</param>
            <exception cref="T:System.InvalidOperationException">
            If the repeated data overflows the window
            </exception>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.Streams.OutputWindow.CopyStored(RT.Servers.SharpZipLib.Zip.Compression.Streams.StreamManipulator,System.Int32)">
            <summary>
            Copy from input manipulator to internal window
            </summary>
            <param name="input">source of data</param>
            <param name="length">length of data to copy</param>
            <returns>the number of bytes copied</returns>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.Streams.OutputWindow.CopyDict(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Copy dictionary to window
            </summary>
            <param name="dictionary">source dictionary</param>
            <param name="offset">offset of start in source dictionary</param>
            <param name="length">length of dictionary</param>
            <exception cref="T:System.InvalidOperationException">
            If window isnt empty
            </exception>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.Streams.OutputWindow.GetFreeSpace">
            <summary>
            Get remaining unfilled space in window
            </summary>
            <returns>Number of bytes left in window</returns>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.Streams.OutputWindow.GetAvailable">
            <summary>
            Get bytes available for output in window
            </summary>
            <returns>Number of bytes filled</returns>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.Streams.OutputWindow.CopyOutput(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Copy contents of window to output
            </summary>
            <param name="output">buffer to copy to</param>
            <param name="offset">offset to start at</param>
            <param name="len">number of bytes to count</param>
            <returns>The number of bytes copied</returns>
            <exception cref="T:System.InvalidOperationException">
            If a window underflow occurs
            </exception>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.Streams.OutputWindow.Reset">
            <summary>
            Reset by clearing window so <see cref="M:RT.Servers.SharpZipLib.Zip.Compression.Streams.OutputWindow.GetAvailable">GetAvailable</see> returns 0
            </summary>
        </member>
        <member name="T:RT.Servers.SharpZipLib.Zip.Compression.Streams.StreamManipulator">
             <summary>
             This class allows us to retrieve a specified number of bits from
             the input buffer, as well as copy big byte blocks.
            
             It uses an int buffer to store up to 31 bits for direct
             manipulation.  This guarantees that we can get at least 16 bits,
             but we only need at most 15, so this is all safe.
            
             There are some optimizations in this class, for example, you must
             never peek more than 8 bits more than needed, and you must first
             peek bits before you may drop them.  This is not a general purpose
             class but optimized for the behaviour of the Inflater.
            
             authors of the original java version : John Leuner, Jochen Hoenicke
             </summary>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.Streams.StreamManipulator.#ctor">
            <summary>
            Constructs a default StreamManipulator with all buffers empty
            </summary>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.Streams.StreamManipulator.PeekBits(System.Int32)">
            <summary>
            Get the next sequence of bits but don't increase input pointer.  bitCount must be
            less or equal 16 and if this call succeeds, you must drop
            at least n - 8 bits in the next call.
            </summary>
            <param name="bitCount">The number of bits to peek.</param>
            <returns>
            the value of the bits, or -1 if not enough bits available.  */
            </returns>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.Streams.StreamManipulator.DropBits(System.Int32)">
            <summary>
            Drops the next n bits from the input.  You should have called PeekBits
            with a bigger or equal n before, to make sure that enough bits are in
            the bit buffer.
            </summary>
            <param name="bitCount">The number of bits to drop.</param>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.Streams.StreamManipulator.GetBits(System.Int32)">
            <summary>
            Gets the next n bits and increases input pointer.  This is equivalent
            to <see cref="M:RT.Servers.SharpZipLib.Zip.Compression.Streams.StreamManipulator.PeekBits(System.Int32)"/> followed by <see cref="M:RT.Servers.SharpZipLib.Zip.Compression.Streams.StreamManipulator.DropBits(System.Int32)"/>, except for correct error handling.
            </summary>
            <param name="bitCount">The number of bits to retrieve.</param>
            <returns>
            the value of the bits, or -1 if not enough bits available.
            </returns>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.Streams.StreamManipulator.SkipToByteBoundary">
            <summary>
            Skips to the next byte boundary.
            </summary>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.Streams.StreamManipulator.CopyBytes(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Copies bytes from input buffer to output buffer starting
            at output[offset].  You have to make sure, that the buffer is
            byte aligned.  If not enough bytes are available, copies fewer
            bytes.
            </summary>
            <param name="output">
            The buffer to copy bytes to.
            </param>
            <param name="offset">
            The offset in the buffer at which copying starts
            </param>
            <param name="length">
            The length to copy, 0 is allowed.
            </param>
            <returns>
            The number of bytes copied, 0 if no bytes were available.
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            Length is less than zero
            </exception>
            <exception cref="T:System.InvalidOperationException">
            Bit buffer isnt byte aligned
            </exception>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.Streams.StreamManipulator.Reset">
            <summary>
            Resets state and empties internal buffers
            </summary>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.Compression.Streams.StreamManipulator.SetInput(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Add more input for consumption.
            Only call when IsNeedingInput returns true
            </summary>
            <param name="buffer">data to be input</param>
            <param name="offset">offset of first byte of input</param>
            <param name="count">number of bytes of input to add.</param>
        </member>
        <member name="P:RT.Servers.SharpZipLib.Zip.Compression.Streams.StreamManipulator.AvailableBits">
            <summary>
            Gets the number of bits available in the bit buffer.  This must be
            only called when a previous PeekBits() returned -1.
            </summary>
            <returns>
            the number of bits available.
            </returns>
        </member>
        <member name="P:RT.Servers.SharpZipLib.Zip.Compression.Streams.StreamManipulator.AvailableBytes">
            <summary>
            Gets the number of bytes available.
            </summary>
            <returns>
            The number of bytes available.
            </returns>
        </member>
        <member name="P:RT.Servers.SharpZipLib.Zip.Compression.Streams.StreamManipulator.IsNeedingInput">
            <summary>
            Returns true when SetInput can be called
            </summary>
        </member>
        <member name="T:RT.Servers.SharpZipLib.Zip.ZipException">
            <summary>
            Represents exception conditions specific to Zip archive handling
            </summary>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.ZipException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Deserialization constructor 
            </summary>
            <param name="info"><see cref="T:System.Runtime.Serialization.SerializationInfo"/> for this constructor</param>
            <param name="context"><see cref="T:System.Runtime.Serialization.StreamingContext"/> for this constructor</param>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.ZipException.#ctor">
            <summary>
            Initializes a new instance of the ZipException class.
            </summary>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.ZipException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the ZipException class with a specified error message.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
        </member>
        <member name="M:RT.Servers.SharpZipLib.Zip.ZipException.#ctor(System.String,System.Exception)">
            <summary>
            Initialise a new instance of ZipException.
            </summary>
            <param name="message">A message describing the error.</param>
            <param name="exception">The exception that is the cause of the current exception.</param>
        </member>
        <member name="T:RT.Servers.SimpleSession">
            <summary>
                Provides functionality to track a session ID in HTTP requests using cookies.</summary>
            <remarks>
                This class only retrieves session IDs from the session cookie and does not handle mapping IDs to session data. It also
                does not automatically create a new session if the HTTP response did not contain a session cookie.</remarks>
        </member>
        <member name="M:RT.Servers.SimpleSession.#ctor(System.String)">
            <summary>
                Constructs a new instance.</summary>
            <param name="cookieName">
                The name of the cookie.</param>
        </member>
        <member name="M:RT.Servers.SimpleSession.DeleteSession">
            <summary>
                Specifies that the session cookie should be deleted by the Handle method. Its value is false initially and right
                after calling Handle().</summary>
        </member>
        <member name="M:RT.Servers.SimpleSession.NewSession(System.String,System.Nullable{System.DateTime},System.String)">
            <summary>
                Specifies that a new session should be created. (The <see cref="M:RT.Servers.SimpleSession.Handle(RT.Servers.HttpRequest,System.Func{RT.Servers.HttpResponse})"/> method adds the relevant cookie to the
                HTTP response.) It also sets the current SessionID to the specified ID.</summary>
            <param name="sessionID">
                The ID for the new session.</param>
            <param name="cookieExpiry">
                If null, the session expires when the client's browser is closed.</param>
            <param name="cookiePath">
                The HTTP URL path to which the cookie should apply.</param>
        </member>
        <member name="M:RT.Servers.SimpleSession.CreateNewSessionId">
            <summary>Returns a random string of 32 characters useful as a session ID.</summary>
        </member>
        <member name="M:RT.Servers.SimpleSession.Handle(RT.Servers.HttpRequest,System.Func{RT.Servers.HttpResponse})">
            <summary>
                Retrieves the session ID from the session cookie (specified by the cookie name) from the given <see cref="T:RT.Servers.HttpRequest"/> and calls the <paramref name="handler"/> function. A session cookie is added to the HTTP
                response returned by the handler only if either <see cref="M:RT.Servers.SimpleSession.DeleteSession"/> or <see cref="M:RT.Servers.SimpleSession.NewSession(System.String,System.Nullable{System.DateTime},System.String)"/> have been
                called (possibly by the handler). Before the possibly augmented HTTP response is returned, the status of
                DeleteSession and NewSession is reset.</summary>
            <param name="req">
                The current HTTP request.</param>
            <param name="handler">
                The inner request handler to execute.</param>
            <returns>
                An HTTP response, possibly augmented with a session cookie.</returns>
        </member>
        <member name="P:RT.Servers.SimpleSession.SessionID">
            <summary>The session ID retrieved from the session cookie.</summary>
        </member>
        <member name="P:RT.Servers.SimpleSession.CookieName">
            <summary>The name of the cookie that contains the session ID.</summary>
        </member>
        <member name="P:RT.Servers.SimpleSession.CookiePath">
            <summary>The path of the retrieved session cookie.</summary>
        </member>
        <member name="P:RT.Servers.SimpleSession.CookieExpires">
            <summary>The expiry date of the retrieved session cookie. If null, the session expires when the client's browser closes.</summary>
        </member>
        <member name="T:RT.Servers.ChunkedEncodingStream">
            <summary>Performs the HTTP Transfer-Encoding “chunked”. This is a write-only stream.</summary>
        </member>
        <member name="M:RT.Servers.ChunkedEncodingStream.#ctor(System.IO.Stream,System.Boolean)">
            <summary>
                Constructs a <see cref="T:RT.Servers.ChunkedEncodingStream"/> object that encodes output in the HTTP Transfer-Encoding
                “chunked”.</summary>
            <param name="inner">
                The underlying stream to write all the output to.</param>
            <param name="leaveInnerOpen">
                If true, the inner stream is not closed when this stream is closed.</param>
        </member>
        <member name="M:RT.Servers.ChunkedEncodingStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
                Writes the specified data to the underlying <see cref="T:System.Net.Sockets.Socket"/> as a single chunk.</summary>
            <param name="buffer">
                Buffer containing the data to be written.</param>
            <param name="offset">
                Buffer offset starting at which data is obtained.</param>
            <param name="count">
                Number of bytes to read from buffer and send to the socket.</param>
        </member>
        <member name="M:RT.Servers.ChunkedEncodingStream.Close">
            <summary>
                Closes this <see cref="T:RT.Servers.ChunkedEncodingStream"/>. It is important that this is called because it outputs the
                trailing null chunk to the socket, indicating the end of the data.</summary>
        </member>
        <member name="T:RT.Servers.Substream">
            <summary>
                Reads a fixed amount of data from a stream. The client code encounters the end of this stream after said fixed amount
                of data is retrieved, even if the underlying stream does not actually end there. This class also allows you to provide
                data from a buffer to “prepend” to the data from the stream (in case you already read a bit too much from the
                underlying stream).</summary>
        </member>
        <member name="M:RT.Servers.Substream.#ctor(System.IO.Stream,System.Int64)">
            <summary>
                Constructs a <see cref="T:RT.Servers.Substream"/> object.</summary>
            <param name="inner">
                The underlying stream to read from.</param>
            <param name="maxBytesToRead">
                Maximum number of bytes to read from the socket. After this, the stream pretends to have reached the end.</param>
        </member>
        <member name="M:RT.Servers.Substream.#ctor(System.IO.Stream,System.Int64,System.Byte[],System.Int32,System.Int32)">
            <summary>
                Constructs a <see cref="T:RT.Servers.Substream"/> object that reads from a given bit of initial data, and then continues on to
                read from the underlying stream.</summary>
            <param name="inner">
                The underlying stream to read from.</param>
            <param name="maxBytesToRead">
                Maximum number of bytes to read from the initial data plus the underlying stream. After this, the stream pretends
                to have reached the end.</param>
            <param name="initialBuffer">
                Buffer containing the initial data. The buffer is not copied, so make sure you don't modify the contents of the
                buffer before it is consumed by reading.</param>
            <param name="initialBufferOffset">
                Offset into the buffer where the initial data starts.</param>
            <param name="initialBufferCount">
                Number of bytes of initial data in the buffer.</param>
        </member>
        <member name="M:RT.Servers.Substream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
                Reads up to the specified number of bytes from the underlying socket.</summary>
            <param name="buffer">
                Buffer to write received data into.</param>
            <param name="offset">
                Offset into the buffer where to start writing.</param>
            <param name="count">
                Maximum number of bytes in the buffer to write to.</param>
            <returns>
                Number of bytes actually written to the buffer.</returns>
        </member>
        <member name="T:RT.Servers.UrlMapping">
            <summary>
                Encapsulates a mapping from URLs to a request handler. Add instances of this class to a <see cref="T:RT.Servers.UrlResolver"/>
                to map URL paths or domains to request handlers. This class is immutable.</summary>
        </member>
        <member name="M:RT.Servers.UrlMapping.#ctor(RT.Servers.UrlHook,System.Func{RT.Servers.HttpRequest,RT.Servers.HttpResponse},System.Boolean)">
            <summary>
                Initialises a new <see cref="T:RT.Servers.UrlMapping"/>.</summary>
            <param name="hook">
                The URL properties to map from.</param>
            <param name="handler">
                The request handler to map to.</param>
            <param name="skippable">
                If <c>true</c>, the handler may be skipped if it returns <c>null</c>.</param>
        </member>
        <member name="M:RT.Servers.UrlMapping.#ctor(System.Func{RT.Servers.HttpRequest,RT.Servers.HttpResponse},System.String,System.Nullable{System.Int32},System.String,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
                Initialises a new <see cref="T:RT.Servers.UrlMapping"/>.</summary>
            <param name="handler">
                The request handler to map to.</param>
            <param name="domain">
                If <c>null</c>, the mapping applies to all domain names. Otherwise, the mapping applies to this domain and all
                subdomains or to this domain only, depending on the value of <paramref name="specificDomain"/>.</param>
            <param name="port">
                If <c>null</c>, the mapping applies to all ports; otherwise to the specified port only.</param>
            <param name="path">
                If <c>null</c>, the mapping applies to all URL paths. Otherwise, the mapping applies to this path and all
                subpaths or to this path only, depending on the value of <paramref name="specificPath"/>.</param>
            <param name="specificDomain">
                If <c>false</c>, the mapping applies to all subdomains of the domain specified by <paramref name="domain"/>.
                Otherwise it applies to the specific domain only.</param>
            <param name="specificPath">
                If <c>false</c>, the mapping applies to all subpaths of the path specified by <paramref name="path"/>.
                Otherwise it applies to the specific path only.</param>
            <param name="skippable">
                If <c>true</c>, the handler may be skipped if it returns <c>null</c>.</param>
        </member>
        <member name="M:RT.Servers.UrlMapping.CompareTo(RT.Servers.UrlMapping)">
            <summary>
                Compares this mapping to another one, and returns a value indicating which mapping should be checked for a
                match first. The ordering is such that more specific mappings are checked first, so that they trigger even if
                a more generic mapping encompasses the specific one. Hence skippable mappings are treated exactly the same,
                and are only reordered with respect to the single non-skippable mapping that matches the exact same request.</summary>
        </member>
        <member name="M:RT.Servers.UrlMapping.Equals(RT.Servers.UrlMapping)">
            <summary>
                Compares mappings for equality. Two mappings are equal if <see cref="P:RT.Servers.UrlMapping.Hook"/> and <see cref="P:RT.Servers.UrlMapping.Skippable"/> are
                equal; <see cref="P:RT.Servers.UrlMapping.Handler"/> is ignored.</summary>
            <seealso cref="M:RT.Servers.UrlHook.Equals(RT.Servers.UrlHook)"/>
        </member>
        <member name="M:RT.Servers.UrlMapping.Equals(System.Object)">
            <summary>
                Compares mappings for equality. Two mappings are equal if <see cref="P:RT.Servers.UrlMapping.Hook"/> and <see cref="P:RT.Servers.UrlMapping.Skippable"/> are
                equal; <see cref="P:RT.Servers.UrlMapping.Handler"/> is ignored.</summary>
        </member>
        <member name="M:RT.Servers.UrlMapping.GetHashCode">
            <summary>
                Computes a hash code suitable as a heuristic for the kind of equality defined by <see cref="M:RT.Servers.UrlMapping.Equals(System.Object)"/>.</summary>
        </member>
        <member name="M:RT.Servers.UrlMapping.ToString">
            <summary>Returns a debugging-friendly representation of this hook's match specification.</summary>
        </member>
        <member name="P:RT.Servers.UrlMapping.Hook">
            <summary>Gets the hook that determines which URLs can trigger the <see cref="P:RT.Servers.UrlMapping.Handler"/>.</summary>
        </member>
        <member name="P:RT.Servers.UrlMapping.Skippable">
            <summary>
                Gets a value indicating whether the <see cref="P:RT.Servers.UrlMapping.Handler"/> may return <c>null</c>, in which case it will be
                skipped and another applicable handler executed instead. Skippable handlers may have a hook identical to that
                of other handlers.</summary>
        </member>
        <member name="P:RT.Servers.UrlMapping.Handler">
            <summary>Gets the request handler for this mapping.</summary>
        </member>
        <member name="T:RT.Servers.QValue`1">
            <summary>
            Encapsulates a value with a Q rating, where Q is between 0 and 1. Provides a comparer such
            that the values with Q = 1 are the smallest.
            </summary>
        </member>
        <member name="M:RT.Servers.QValue`1.#ctor(System.Single,`0)">
            <summary>Constructs a new q value</summary>
        </member>
        <member name="M:RT.Servers.QValue`1.op_Implicit(RT.Servers.QValue{`0})~`0">
            <summary>Gets the value via an implicit conversion</summary>
        </member>
        <member name="M:RT.Servers.QValue`1.CompareTo(RT.Servers.QValue{`0})">
            <summary>Compares the Q number of this Q-value to the other one.</summary>
        </member>
        <member name="M:RT.Servers.QValue`1.ToString">
            <summary>Converts the q value to a string.</summary>
        </member>
        <member name="P:RT.Servers.QValue`1.Q">
            <summary>Gets the Q number</summary>
        </member>
        <member name="T:RT.Servers.WValue">
            <summary>Encapsulates a string value that can additionally be either weak or not.</summary>
        </member>
        <member name="M:RT.Servers.WValue.#ctor(System.String)">
            <summary>Constructs a non-weak value.</summary>
        </member>
        <member name="M:RT.Servers.WValue.#ctor(System.String,System.Boolean)">
            <summary>Constructor.</summary>
        </member>
        <member name="M:RT.Servers.WValue.ToString">
            <summary>Override; see base.</summary>
        </member>
        <member name="P:RT.Servers.WValue.Value">
            <summary>Gets or sets the value.</summary>
        </member>
        <member name="P:RT.Servers.WValue.Weak">
            <summary>Gets or sets whether the value is “weak”.</summary>
        </member>
        <member name="T:RT.Servers.Resources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:RT.Servers.Resources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:RT.Servers.Resources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:RT.Servers.Resources.bmp_16">
            <summary>
              Looks up a localized resource of type System.Byte[].
            </summary>
        </member>
        <member name="P:RT.Servers.Resources.csv_16">
            <summary>
              Looks up a localized resource of type System.Byte[].
            </summary>
        </member>
        <member name="P:RT.Servers.Resources.doc_16">
            <summary>
              Looks up a localized resource of type System.Byte[].
            </summary>
        </member>
        <member name="P:RT.Servers.Resources.exe_16">
            <summary>
              Looks up a localized resource of type System.Byte[].
            </summary>
        </member>
        <member name="P:RT.Servers.Resources.faq_16">
            <summary>
              Looks up a localized resource of type System.Byte[].
            </summary>
        </member>
        <member name="P:RT.Servers.Resources.folder_16">
            <summary>
              Looks up a localized resource of type System.Byte[].
            </summary>
        </member>
        <member name="P:RT.Servers.Resources.folder_48">
            <summary>
              Looks up a localized resource of type System.Byte[].
            </summary>
        </member>
        <member name="P:RT.Servers.Resources.gz_16">
            <summary>
              Looks up a localized resource of type System.Byte[].
            </summary>
        </member>
        <member name="P:RT.Servers.Resources.jpg_16">
            <summary>
              Looks up a localized resource of type System.Byte[].
            </summary>
        </member>
        <member name="P:RT.Servers.Resources.pdf_16">
            <summary>
              Looks up a localized resource of type System.Byte[].
            </summary>
        </member>
        <member name="P:RT.Servers.Resources.pic_16">
            <summary>
              Looks up a localized resource of type System.Byte[].
            </summary>
        </member>
        <member name="P:RT.Servers.Resources.png_16">
            <summary>
              Looks up a localized resource of type System.Byte[].
            </summary>
        </member>
        <member name="P:RT.Servers.Resources.pps_16">
            <summary>
              Looks up a localized resource of type System.Byte[].
            </summary>
        </member>
        <member name="P:RT.Servers.Resources.ppt_16">
            <summary>
              Looks up a localized resource of type System.Byte[].
            </summary>
        </member>
        <member name="P:RT.Servers.Resources.txt_16">
            <summary>
              Looks up a localized resource of type System.Byte[].
            </summary>
        </member>
        <member name="P:RT.Servers.Resources.xls_16">
            <summary>
              Looks up a localized resource of type System.Byte[].
            </summary>
        </member>
        <member name="P:RT.Servers.Resources.zip_16">
            <summary>
              Looks up a localized resource of type System.Byte[].
            </summary>
        </member>
        <member name="T:RT.Servers.Session">
            <summary>
                Provides functionality to track user sessions in HTTP requests using cookies. See remarks for usage guidelines.</summary>
            <remarks>
                <para>
                    Intended use is as follows:</para>
                <list type="bullet">
                    <item><description>
                        Declare a class containing one or more fields which constitute your session data.</description></item>
                    <item><description>
                        Derive that class from <see cref="T:RT.Servers.Session"/>, <see cref="T:RT.Servers.FileSession"/>, or your own specialization of
                        either.</description></item>
                    <item><description>
                        <para>
                            You can now augment any HTTP request handler that looks like this:</para>
                        <code>
                            req =&gt; { /* code to handle request, no session support */ }</code>
                        <para>
                            by changing it into this:</para>
                        <code>
                            req =&gt; Session.EnableAutomatic&lt;TSession&gt;(req, session =&gt; {
                                /* code to handle request with session variable available */
                            })</code>
                        <para>
                            (replace <c>TSession</c> with the name of your derived class; see <see cref="M:RT.Servers.Session.EnableAutomatic``1(RT.Servers.HttpRequest,System.Func{``0,RT.Servers.HttpResponse})"/> or <see cref="M:RT.Servers.Session.EnableManual``1(RT.Servers.HttpRequest,System.Func{``0,RT.Servers.HttpResponse})"/>).</para></description></item>
                    <item><description>
                        Within your request handler, you can make arbitrary changes to the session object, which will be persisted
                        automatically.</description></item>
                    <item><description>
                        If you use <see cref="M:RT.Servers.Session.EnableManual``1(RT.Servers.HttpRequest,System.Func{``0,RT.Servers.HttpResponse})"/>, <see cref="P:RT.Servers.Session.SessionModified"/> must be set to <c>true</c> whenever
                        any value in the session object is changed.</description></item>
                    <item><description>
                        If you use <see cref="M:RT.Servers.Session.EnableAutomatic``1(RT.Servers.HttpRequest,System.Func{``0,RT.Servers.HttpResponse})"/>, the session
                        object must implement <see cref="T:RT.Servers.ISessionEquatable`1"/>. In this case, modifications to the
                        session object are detected by taking a clone of the session object, then running the request handler, and
                        then comparing the two.</description></item>
                    <item><description>
                        You can set <see cref="P:RT.Servers.Session.Action"/> if you want the session reverted or deleted.</description></item></list></remarks>
        </member>
        <member name="M:RT.Servers.Session.ToString">
            <summary>Returns a string representation of this session object.</summary>
        </member>
        <member name="M:RT.Servers.Session.ReadSession">
            <summary>
                When overridden in a derived class, attempts to retrieve an existing session (identified by <see cref="P:RT.Servers.Session.SessionID"/>) from the session store and initialises this instance with the relevant data. If no such
                session as identified by <see cref="P:RT.Servers.Session.SessionID"/> is found in the session store, returns false.</summary>
        </member>
        <member name="M:RT.Servers.Session.NewSession">
            <summary>
                Initializes a new session whenever an existing one couldn’t be read. Must not save the session; only
                initialize any session variables. The default implementation does nothing, so derived classes don’t need to
                call it.</summary>
        </member>
        <member name="M:RT.Servers.Session.SaveSession">
            <summary>When overridden in a derived class, saves this instance to the session store.</summary>
        </member>
        <member name="M:RT.Servers.Session.DeleteSession">
            <summary>
                When overridden in a derived class, deletes this session (identified by <see cref="P:RT.Servers.Session.SessionID"/>) from the
                session store. This method is not called if <see cref="M:RT.Servers.Session.ReadSession"/> returned false, indicating that no
                session was available.</summary>
        </member>
        <member name="M:RT.Servers.Session.InitialiseFromRequest(RT.Servers.HttpRequest)">
            <summary>
                Initialises this session instance from the specified request. Only call this if you are not using <see cref="M:RT.Servers.Session.EnableAutomatic``1(RT.Servers.HttpRequest,System.Func{``0,RT.Servers.HttpResponse})"/>, <see cref="M:RT.Servers.Session.EnableAutomatic``1(RT.Servers.HttpRequest,System.Func{``0,RT.Servers.HttpResponse},System.Func{``0})"/> or <see cref="M:RT.Servers.Session.EnableManual``1(RT.Servers.HttpRequest,System.Func{``0,RT.Servers.HttpResponse})"/>, as that already calls it.</summary>
            <param name="req">
                Request containing the cookie information from which to initialise the session.</param>
        </member>
        <member name="M:RT.Servers.Session.CleanUp(RT.Servers.HttpResponse,System.Boolean)">
            <summary>
                Saves/deletes the session and/or sets the session cookie, as appropriate. Only call this if you are not using
                <see cref="M:RT.Servers.Session.EnableAutomatic``1(RT.Servers.HttpRequest,System.Func{``0,RT.Servers.HttpResponse})"/>, <see cref="M:RT.Servers.Session.EnableAutomatic``1(RT.Servers.HttpRequest,System.Func{``0,RT.Servers.HttpResponse},System.Func{``0})"/> or <see cref="M:RT.Servers.Session.EnableManual``1(RT.Servers.HttpRequest,System.Func{``0,RT.Servers.HttpResponse})"/>, as that already calls it.</summary>
            <param name="response">
                Response to add cookie information to.</param>
            <param name="wasModified">
                Specifies whether the session data has changed.</param>
        </member>
        <member name="M:RT.Servers.Session.EnableAutomatic``1(RT.Servers.HttpRequest,System.Func{``0,RT.Servers.HttpResponse})">
            <summary>
                Enables the use of sessions in an HTTP request handler. Use this if your session class implements <see cref="T:RT.Servers.ISessionEquatable`1"/> and has a default constructor.</summary>
            <typeparam name="TSession">
                The type of session to be used.</typeparam>
            <param name="req">
                The HTTP request for which to enable session support.</param>
            <param name="handler">
                HTTP request handler code that can make free use of a session variable.</param>
            <remarks>
                See the remarks section in the <see cref="T:RT.Servers.Session"/> documentation for usage guidelines.</remarks>
            <seealso cref="M:RT.Servers.Session.EnableAutomatic``1(RT.Servers.HttpRequest,System.Func{``0,RT.Servers.HttpResponse},System.Func{``0})"/>
            <seealso cref="M:RT.Servers.Session.EnableManual``1(RT.Servers.HttpRequest,System.Func{``0,RT.Servers.HttpResponse})"/>
        </member>
        <member name="M:RT.Servers.Session.EnableAutomatic``1(RT.Servers.HttpRequest,System.Func{``0,RT.Servers.HttpResponse},System.Func{``0})">
            <summary>
                Enables the use of sessions in an HTTP request handler. Use this if your session class implements <see cref="T:RT.Servers.ISessionEquatable`1"/>.</summary>
            <typeparam name="TSession">
                The type of session to be used.</typeparam>
            <param name="req">
                The HTTP request for which to enable session support.</param>
            <param name="handler">
                HTTP request handler code that can make free use of a session variable.</param>
            <param name="constructor">
                A delegate that can be used to create an instance of the session class. (If your session class has a
                parameterless constructor, consider using <see cref="M:RT.Servers.Session.EnableAutomatic``1(RT.Servers.HttpRequest,System.Func{``0,RT.Servers.HttpResponse})"/> instead.)</param>
            <remarks>
                See the remarks section in the <see cref="T:RT.Servers.Session"/> documentation for usage guidelines.</remarks>
            <seealso cref="M:RT.Servers.Session.EnableAutomatic``1(RT.Servers.HttpRequest,System.Func{``0,RT.Servers.HttpResponse})"/>
            <seealso cref="M:RT.Servers.Session.EnableManual``1(RT.Servers.HttpRequest,System.Func{``0,RT.Servers.HttpResponse})"/>
        </member>
        <member name="M:RT.Servers.Session.EnableManual``1(RT.Servers.HttpRequest,System.Func{``0,RT.Servers.HttpResponse})">
            <summary>
                Enables the use of sessions in an HTTP request handler. Use this if your session class does not implement <see cref="T:RT.Servers.ISessionEquatable`1"/>; your class will have to manually set <see cref="P:RT.Servers.Session.SessionModified"/> to
                <c>true</c> before the request handler returns if any change was made to the session.</summary>
            <typeparam name="TSession">
                The type of session to be used.</typeparam>
            <param name="req">
                The HTTP request for which to enable session support.</param>
            <param name="handler">
                HTTP request handler code that can make free use of a session variable.</param>
            <remarks>
                See the remarks section in the <see cref="T:RT.Servers.Session"/> documentation for usage guidelines.</remarks>
        </member>
        <member name="P:RT.Servers.Session.SessionModified">
            <summary>
                True if a new session was created, or any of the session variables were modified. Derived classes should set
                this to true whenever a session variable is modified. Set this to false to discard all session changes
                (otherwise they will be saved upon session <see cref="M:RT.Servers.Session.CleanUp(RT.Servers.HttpResponse,System.Boolean)"/>).</summary>
        </member>
        <member name="P:RT.Servers.Session.CookieModified">
            <summary>
                True if a new session was created, or any of the cookie parameters were modified (such as <see cref="P:RT.Servers.Session.CookieExpires"/>).</summary>
        </member>
        <member name="P:RT.Servers.Session.Action">
            <summary>Controls what happens to the session data when the request handler returns.</summary>
        </member>
        <member name="P:RT.Servers.Session.SessionID">
            <summary>Contains the session ID, which is also the cookie value.</summary>
        </member>
        <member name="P:RT.Servers.Session.CookieName">
            <summary>
                When overridden in a derived class, gets the name of the cookie that contains the user’s session ID.</summary>
            <remarks>
                This property should always return the same value, otherwise the behaviour is undefined. The default
                implementation returns <c>this.GetType().Name</c>.</remarks>
        </member>
        <member name="P:RT.Servers.Session.CookiePath">
            <summary>
                When overridden in a derived class, gets the applicable cookie Path for the cookie that contains the user’s
                session ID.</summary>
            <remarks>
                This property should always return the same value, otherwise the behaviour is undefined. The default
                implementation returns <c>"/"</c>.</remarks>
        </member>
        <member name="P:RT.Servers.Session.CookieExpires">
            <summary>
                When overridden in a derived class, gets the expiry date/time of the cookie that contains the user’s session
                ID.</summary>
            <remarks>
                <para>
                    If the property value is variable, ensure that <see cref="P:RT.Servers.Session.CookieModified"/> is set to true before the
                    request handler returns.</para>
                <para>
                    The default implementation returns <c>DateTime.MaxValue</c>.</para></remarks>
        </member>
        <member name="T:RT.Servers.SessionAction">
            <summary>Specifies an action to perform on the session object when the request handler returns.</summary>
        </member>
        <member name="F:RT.Servers.SessionAction.Save">
            <summary>Causes changes to the session to be saved.</summary>
        </member>
        <member name="F:RT.Servers.SessionAction.DoNothing">
            <summary>
                Cause any changes to the session to be ignored. The next request will receive the previous state of the
                session.</summary>
        </member>
        <member name="F:RT.Servers.SessionAction.Delete">
            <summary>
                Cause the session and the associated cookie to be deleted. The deletion occurs in <see cref="M:RT.Servers.Session.CleanUp(RT.Servers.HttpResponse,System.Boolean)"/>.</summary>
        </member>
        <member name="T:RT.Servers.ISessionEquatable`1">
            <summary>
                Provides functionality required by <see cref="M:RT.Servers.Session.EnableAutomatic``1(RT.Servers.HttpRequest,System.Func{``0,RT.Servers.HttpResponse})"/>.</summary>
            <typeparam name="TSession">
                The type of the session object.</typeparam>
        </member>
        <member name="M:RT.Servers.ISessionEquatable`1.DeepClone">
            <summary>Takes a deep clone of this session object.</summary>
        </member>
        <member name="T:RT.Servers.FileSession">
            <summary>
                Provides functionality to track user sessions in HTTP requests using cookies and to store such user sessions in
                the local file system.</summary>
            <remarks>
                In order to use this class, you must create a class that derives from it. See the remarks section in the <see cref="T:RT.Servers.Session"/> documentation for usage guidelines.</remarks>
        </member>
        <member name="F:RT.Servers.FileSession._lock">
            <summary>Used to prevent concurrent read/write access to session files.</summary>
        </member>
        <member name="M:RT.Servers.FileSession.ReadSession">
            <summary>Retrieves an existing session from the file system and initialises this instance with the relevant data.</summary>
        </member>
        <member name="M:RT.Servers.FileSession.SaveSession">
            <summary>Saves this instance to the file system.</summary>
        </member>
        <member name="M:RT.Servers.FileSession.DeleteSession">
            <summary>Deletes the file containing the data for this session from the file system.</summary>
        </member>
        <member name="P:RT.Servers.FileSession.SessionPath">
            <summary>
                Gets the folder in which session data should be stored.</summary>
            <remarks>
                The default implementation returns <c>Path.Combine(Path.GetTempPath(), "sessions")</c>.</remarks>
        </member>
        <member name="T:RT.Servers.UrlHook">
            <summary>
                Encapsulates properties of a URL that can be mapped to a request handler using <see cref="T:RT.Servers.UrlMapping"/>. This
                class is immutable.</summary>
        </member>
        <member name="M:RT.Servers.UrlHook.#ctor(System.String,System.Nullable{System.Int32},System.String,System.Boolean,System.Boolean,RT.Servers.Protocols)">
            <summary>
                Initializes a new <see cref="T:RT.Servers.UrlHook"/>.</summary>
            <param name="domain">
                If <c>null</c>, the hook applies to all domain names. Otherwise, the hook applies to this domain and all
                subdomains or to this domain only, depending on the value of <paramref name="specificDomain"/>.</param>
            <param name="port">
                If <c>null</c>, the hook applies to all ports; otherwise to the specified port only.</param>
            <param name="path">
                If <c>null</c>, the hook applies to all URL paths. Otherwise, the hook applies to this path and all subpaths
                or to this path only, depending on the value of <paramref name="specificPath"/>.</param>
            <param name="specificDomain">
                If <c>false</c>, the hook applies to all subdomains of the domain specified by <paramref name="domain"/>.
                Otherwise it applies to the specific domain only.</param>
            <param name="specificPath">
                If <c>false</c>, the hook applies to all subpaths of the path specified by <paramref name="path"/>. Otherwise
                it applies to the specific path only.</param>
            <param name="protocols">
                Specifies the protocol(s) to hook to. Default is all supported protocols.</param>
        </member>
        <member name="M:RT.Servers.UrlHook.#ctor(System.String,System.Boolean,System.Boolean,RT.Servers.Protocols)">
            <summary>
                Initializes a new <see cref="T:RT.Servers.UrlHook"/>.</summary>
            <param name="pathOrDomain">
                Specifies the path or the domain this hook shall apply to.</param>
            <param name="useDomain">
                Specifies whether <paramref name="pathOrDomain"/> is a path or a domain.</param>
            <param name="specific">
                If <c>false</c>, the hook applies to all subpaths/subdomains of the path/domain specified by <paramref name="pathOrDomain"/>. Otherwise it applies to the specific path/domain only.</param>
            <param name="protocols">
                Specifies the protocol(s) to hook to. Default is all supported protocols.</param>
        </member>
        <member name="M:RT.Servers.UrlHook.CompareTo(RT.Servers.UrlHook)">
            <summary>
                Compares this hook to another one such that more specific hooks are sorted before a more generic hook that
                encompasses the specific one.</summary>
        </member>
        <member name="M:RT.Servers.UrlHook.countBits(System.Int32)">
            <summary>Returns the number of 1-bits in the input integer.</summary>
        </member>
        <member name="M:RT.Servers.UrlHook.Equals(RT.Servers.UrlHook)">
            <summary>Compares mappings for equality.</summary>
        </member>
        <member name="M:RT.Servers.UrlHook.Equals(System.Object)">
            <summary>Compares mappings for equality.</summary>
        </member>
        <member name="M:RT.Servers.UrlHook.GetHashCode">
            <summary>
                Computes a hash code suitable as a heuristic for the kind of equality defined by <see cref="M:RT.Servers.UrlHook.Equals(System.Object)"/>.</summary>
        </member>
        <member name="M:RT.Servers.UrlHook.ToString">
            <summary>Returns a debugging-friendly representation of this hook's match specification.</summary>
        </member>
        <member name="P:RT.Servers.UrlHook.Domain">
            <summary>
                Gets a value indicating what domain name the hook applies to. Returns <c>null</c> if it applies to all
                domains.</summary>
            <seealso cref="P:RT.Servers.UrlHook.SpecificDomain"/>
        </member>
        <member name="P:RT.Servers.UrlHook.Port">
            <summary>Gets a value indicating what port the hook applies to. Returns <c>null</c> if it applies to all ports.</summary>
        </member>
        <member name="P:RT.Servers.UrlHook.Path">
            <summary>
                Gets a value indicating what URL path the hook applies to. Returns <c>null</c> if it applies to all paths.</summary>
            <seealso cref="P:RT.Servers.UrlHook.SpecificPath"/>
        </member>
        <member name="P:RT.Servers.UrlHook.SpecificDomain">
            <summary>
                Gets a value indicating whether the hook applies to all subdomains of the domain specified by <see cref="P:RT.Servers.UrlHook.Domain"/> (<c>false</c>) or the specific domain only (<c>true</c>).</summary>
        </member>
        <member name="P:RT.Servers.UrlHook.SpecificPath">
            <summary>
                Gets a value indicating whether the hook applies to all subpaths of the path specified by <see cref="P:RT.Servers.UrlHook.Path"/>
                (<c>false</c>) or to the specific path only (<c>true</c>).</summary>
        </member>
        <member name="P:RT.Servers.UrlHook.Protocols">
            <summary>Gets a value indicating the protocol(s) to which the hook applies.</summary>
        </member>
        <member name="T:RT.Servers.UrlResolver">
            <summary>
                Allows you to specify mappings that map URLs to HTTP request handlers.</summary>
            <remarks>
                Maintains a collection of <see cref="T:RT.Servers.UrlMapping"/> objects, making sure that they are always enumerated in a
                sensible order and ensuring that there are no duplicate hooks added in error. This class is thread-safe except for
                enumeration; to enumerate the mappings safely, you must hold a lock on the instance until the enumeration is
                completed.</remarks>
        </member>
        <member name="M:RT.Servers.UrlResolver.#ctor">
            <summary>
                Constructs an empty <see cref="T:RT.Servers.UrlResolver"/> with no mappings. Use <see cref="M:RT.Servers.UrlResolver.Add(RT.Servers.UrlMapping)"/>, <see cref="M:RT.Servers.UrlResolver.Add(RT.Servers.UrlHook,System.Func{RT.Servers.HttpRequest,RT.Servers.HttpResponse},System.Boolean)"/> or <see cref="M:RT.Servers.UrlResolver.AddRange(System.Collections.Generic.IEnumerable{RT.Servers.UrlMapping})"/> to add mappings.</summary>
        </member>
        <member name="M:RT.Servers.UrlResolver.#ctor(System.Collections.Generic.IEnumerable{RT.Servers.UrlMapping})">
            <summary>Initializes this <see cref="T:RT.Servers.UrlResolver"/> with the specified collection of mappings.</summary>
        </member>
        <member name="M:RT.Servers.UrlResolver.#ctor(RT.Servers.UrlMapping[])">
            <summary>Initializes this <see cref="T:RT.Servers.UrlResolver"/> with the specified collection of mappings.</summary>
        </member>
        <member name="M:RT.Servers.UrlResolver.Handle(RT.Servers.HttpRequest)">
            <summary>
                Handles an HTTP request by delegating it to the appropriate handler according to the request’s URL.</summary>
            <param name="req">
                Incoming HTTP request.</param>
            <returns>
                The HTTP response that was returned by the first applicable mapping.</returns>
            <remarks>
                Assign this method to <see cref="P:RT.Servers.HttpServer.Handler"/>.</remarks>
        </member>
        <member name="M:RT.Servers.UrlResolver.Contains(RT.Servers.UrlMapping)">
            <summary>Determines whether a mapping with the same match specification is present in this collection.</summary>
        </member>
        <member name="M:RT.Servers.UrlResolver.GetEnumerator">
            <summary>
                Enumerates the mappings. To maintain thread safety, you must hold a lock on <see cref="P:RT.Servers.UrlResolver.Locker"/> until the
                enumeration is finished.</summary>
        </member>
        <member name="M:RT.Servers.UrlResolver.System#Collections#IEnumerable#GetEnumerator">
            <summary>
                Enumerates the mappings. To maintain thread safety, you must hold a lock on <see cref="P:RT.Servers.UrlResolver.Locker"/> until the
                enumeration is finished.</summary>
        </member>
        <member name="M:RT.Servers.UrlResolver.CopyTo(RT.Servers.UrlMapping[],System.Int32)">
            <summary>Throws NotImplementedException.</summary>
        </member>
        <member name="M:RT.Servers.UrlResolver.Clear">
            <summary>Removes all mappings from this collection.</summary>
        </member>
        <member name="M:RT.Servers.UrlResolver.Add(RT.Servers.UrlMapping)">
            <summary>Adds the specified mapping to this collection.</summary>
        </member>
        <member name="M:RT.Servers.UrlResolver.Add(RT.Servers.UrlHook,System.Func{RT.Servers.HttpRequest,RT.Servers.HttpResponse},System.Boolean)">
            <summary>Adds the specified mapping to this collection.</summary>
        </member>
        <member name="M:RT.Servers.UrlResolver.AddRange(System.Collections.Generic.IEnumerable{RT.Servers.UrlMapping})">
            <summary>
                Efficiently adds multiple mappings to this collection. Use this method whenever adding multiple mappings at
                once.</summary>
        </member>
        <member name="M:RT.Servers.UrlResolver.Remove(RT.Servers.UrlMapping)">
            <summary>
                Removes a mapping that is equal to the specified mapping.</summary>
            <remarks>
                This will remove a mapping with a different handler if everything else about it is equal. See <see cref="M:RT.Servers.UrlMapping.Equals(RT.Servers.UrlMapping)"/>.</remarks>
        </member>
        <member name="M:RT.Servers.UrlResolver.Remove(RT.Servers.UrlHook)">
            <summary>
                Removes all mappings with a hook equivalent to the specified one.</summary>
            <returns>
                The number of elements removed.</returns>
        </member>
        <member name="P:RT.Servers.UrlResolver.Locker">
            <summary>Take a lock on this object to perform multiple add/remove/clear operations atomically.</summary>
        </member>
        <member name="P:RT.Servers.UrlResolver.Count">
            <summary>Gets a value indicating the number of mappings in this collection.</summary>
        </member>
        <member name="P:RT.Servers.UrlResolver.IsReadOnly">
            <summary>Returns false.</summary>
        </member>
        <member name="T:RT.Servers.HttpResponseWebSocket">
            <summary>
                Encapsulates a response to an HTTP request that indicates to the client that they should switch to the WebSocket
                protocol.</summary>
        </member>
        <member name="M:RT.Servers.HttpResponseWebSocket.#ctor(RT.Servers.WebSocket,System.String,RT.Servers.HttpResponseHeaders)">
            <summary>
                Constructor.</summary>
            <param name="websocket">
                The <see cref="T:RT.Servers.WebSocket"/> implementation to use for the remainder of the connection.</param>
            <param name="subprotocol">
                The server’s selection of a subprotocol, if the client specified any subprotocols in the request.</param>
            <param name="headers">
                Optional HTTP response headers.</param>
        </member>
        <member name="P:RT.Servers.HttpResponseWebSocket.Status">
            <summary>The HTTP status code. For example, 200 OK, 404 Not Found, 500 Internal Server Error. Default is 200 OK.</summary>
        </member>
        <member name="P:RT.Servers.HttpResponseWebSocket.Subprotocol">
            <summary>The server’s selection of a subprotocol, if the client specified any subprotocols in the request.</summary>
        </member>
        <member name="P:RT.Servers.HttpResponseWebSocket.Websocket">
            <summary>The <see cref="T:RT.Servers.WebSocket"/> implementation to use for the remainder of the connection.</summary>
        </member>
    </members>
</doc>
